<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  

  <title>Traveling salesman problem</title>
  <meta name="description" content="The traveling salesman problem is one of those annoying interview questions you sometimes get hurled towards you, accompanied with “how would you solve this”? I remember a time where I was 
a fresh hatchling straight out of college, finding myself in that exact situation. I’ll spare you the details, but I can tell you I didn’t get particularly far ;-)

">
  <meta name="author" content="Tom van Schaijk">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Traveling salesman problem">
  <meta name="twitter:description" content="The traveling salesman problem is one of those annoying interview questions you sometimes get hurled towards you, accompanied with “how would you solve this”? I remember a time where I was 
a fresh hatchling straight out of college, finding myself in that exact situation. I’ll spare you the details, but I can tell you I didn’t get particularly far ;-)

">
  
  <meta name="twitter:image" content="/images/favicons/favicon-194x194.png" />

  <meta property="og:type" content="article">
  <meta property="og:title" content="Traveling salesman problem">
  <meta property="og:description" content="The traveling salesman problem is one of those annoying interview questions you sometimes get hurled towards you, accompanied with “how would you solve this”? I remember a time where I was 
a fresh hatchling straight out of college, finding myself in that exact situation. I’ll spare you the details, but I can tell you I didn’t get particularly far ;-)

">
  <meta property="og:image" content="/images/favicons/favicon.png?" />

  <link rel="apple-touch-icon" sizes="57x57" href="/images/favicons/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/images/favicons/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/images/favicons/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/favicons/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/images/favicons/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/images/favicons/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/images/favicons/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/images/favicons/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-touch-icon-180x180.png">
  <!-- <link rel="icon" type="image/png" href="/images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-194x194.png" sizes="194x194">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="/images/favicons/android-chrome-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-16x16.png" sizes="16x16"> -->
  <link rel="manifest" href="/images/favicons/manifest.json">
  <link rel="shortcut icon" type="image/png" href="/images/favicons/favicon.png?">
  <meta name="msapplication-TileColor" content="#ffc40d">
  <meta name="msapplication-TileImage" content="/images/favicons/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">
  
  <link rel="stylesheet" href="/css/main.css?1682909671007910591">
  <link rel="canonical" href="http://localhost:4000/2023/traveling-salesman/">
  <link rel="alternate" type="application/rss+xml" title="Peculiar Coding Endeavours" href="/feed.xml">
</head>


  <body>
    <span class="mobile btn-mobile-menu">
  <i class="icon icon-list btn-mobile-menu__icon"></i>
  <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
</span>

<header class="panel-cover" style="background-image: url(/images/cover.jpg)">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">
        <a href="/" title="Peculiar Coding Endeavours Home">
          <img src="/images/profile.jpg" class="user-image" alt="My Profile Photo">
          <h1 class="panel-cover__title panel-title">Peculiar Coding Endeavours</h1>
        </a>
        <hr class="panel-cover__divider">
        <p class="panel-cover__description">Software engineer. Algorithm & data structures nut. On my way to learning AI. Eternal student.</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="Blog" class="blog-button">Blog</a></li>
            </ul>
          </nav>

          <nav class="cover-navigation navigation--social">
            <ul class="navigation">
            
              
              <!-- YouTube -->
              <li class="navigation__item">
                <a href="https://www.youtube.com/@peculiar-coding-endeavours" title="YouTube" target="_blank">
                  <i class="icon icon-social-youtube"></i>
                  <span class="label">YouTube</span>
                </a>
              </li>
            

            
            <!-- GitHub -->
            <li class="navigation__item">
              <a href="https://www.github.com/tomvanschaijk" title="GitHub" target="_blank">
                <i class="icon icon-social-github"></i>
                <span class="label">GitHub</span>
              </a>
            </li>
          

            
              <!-- LinkedIn -->
              <li class="navigation__item">
                <a href="https://www.linkedin.com/in/tom-van-schaijk" title="LinkedIn" target="_blank">
                  <i class="icon icon-social-linkedin"></i>
                  <span class="label">LinkedIn</span>
                </a>
              </li>
            

            
              <!-- Email -->
              <li class="navigation__item">
                <a href="mailto:vanschaijktom@hotmail.com" title="vanschaijktom@hotmail.com" target="_blank">
                  <i class="icon icon-mail"></i>
                  <span class="label">Email</span>
                </a>
              </li>
            

            <!-- RSS -->
            <li class="navigation__item">
              <a href="/feed.xml" title="Subscribe" target="_blank">
                <i class="icon icon-rss"></i>
                <span class="label">RSS</span>
              </a>
            </li>

            </ul>
          </nav>

        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>


    <div class="content-wrapper">
      <div class="content-wrapper__inner">
        <article class="post-container post-container--single">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="1 Apr 2023" class="post-meta__date date">1 Apr 2023</time>
      
      &#8226; <span class="post-meta__tags">on <a href="/tags/#tsp">tsp</a> <a href="/tags/#algorithms">algorithms</a> <a href="/tags/#python">python</a> </span>
      
    </div>
    <h1 class="post-title">Traveling salesman problem</h1>
  </header>

  <section class="post">
    <p>The traveling salesman problem is one of those annoying interview questions you sometimes get hurled towards you, accompanied with “how would you solve this”? I remember a time where I was 
a fresh hatchling straight out of college, finding myself in that exact situation. I’ll spare you the details, but I can tell you I didn’t get particularly far ;-)</p>

<p>Times change though, and over the years I grew into the type of software engineer that definitely prefers to work with data structures and algorithms over the next “best” framework used to make text and images appear in a web browser. If that happens to be your cup of tea though, don’t get too offended, I’m an ignorant back-end kind of guy, and you will undoubtedly run circles around me if it comes to any
front-end related tech.</p>

<p><img src="http://localhost:4000/assets/tsp/salesmen.jpg" alt="salesmen" /></p>

<h3 id="some-solutions">Some solutions…</h3>

<p>Now, quite a few years later, I thought it’d be a nice moment to provide a few potential solutions, and give you a little bit of a summary regarding how to go about it. I assume you know what the <a href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" target="_blank">Traveling Salesman Problem</a> entails, at least from a high level. In short, the goal is to find the Hamiltonian cycle in an undirected weighted graph with the lowest cost. It’s one of those nice annoying NP-hard problems, so more than enough ways to have fun with it. It has many applications, from planning, logistics to manifacturing microchips. In this article, I’ll go over 4 example implementations of possible solutions to the problem:</p>
<ul>
  <li>a simple brute force algorithm, guaranteed to give you the optimal shortest distance, but obviously horribly slow</li>
  <li>another guaranteed optimal solution, but quite a bit more efficient, using dynamic programming</li>
  <li>an approximation of a solution using genetic algorithms</li>
  <li>another approximation, using ant colony optimization</li>
</ul>

<p>I’ve been interested in genetic algorithms and ant colony optimization for a while now, and the traveling salesman problem is a nice use-case to apply these algorithms to. In case you are not familiar with one or either of them, you can find more information about <a href="https://en.wikipedia.org/wiki/Genetic_algorithm">Genetic algorithms</a> and <a href="https://en.wikipedia.org/wiki/Ant_colony_optimization_algorithms">Ant Colony Optimization</a> all over the internet. Or you can ask ChatGPT, apparently that’s quite the trend lately. There’s several other ways to go about finding solutions like simulated annealing, n-opt and several of its variations, but I wanted to stick to what triggered my curiosity the most.</p>

<h3 id="the-project">The project</h3>
<p>The full code of the project is available on my <a href="https://github.com/tomvanschaijk/travelingsalesman" target="_blank">GitHub</a>. The requirements to run it are pretty basic. It’s all Python code, and I mainly use PyGame, Numpy, Asyncio and Aiostream. Just install the requirements in requirements.txt and you’ll be set. You can preview the end result right <a href="https://youtu.be/XCZSwM--vCA" target="_blank">here</a>. In fact, give that a quick gander, keep it open in your browser, and the rest of the article will quickly become clear. Obviously, cloning it yourself and running it will help your understanding even more.</p>

<p>The PyGame window that pops up when running shows you 5 panes. The top center one is the one where you can left-click to add points. These points will be the destinations our supposed salesman will have to visit. The first point you create will be green, and will be the starting point and end destination. All other blue ones are the cities to be visited before getting back to the starting point. Hitting spacebar will reset the screen, enter starts the algorithm. The distances between points is simply the Euclidean distance in pixels between the points.</p>

<p>Since the brute force and dynamic programming solutions are inherently slow for anything more than a few points, you’ll notice there’s a cut-off point where those algorithms are not being taken along for the ride anymore. It would simply take too much time, as the time complexity for both just explodes when the amount of points gets too high. Dynamic programming will be used for a bit longer than brute force, but when you start getting in the double digits in terms of destination count, both will not be executed anymore.</p>

<p>In case you do follow along in the code and you check out the GitHub project, there’s not a lot of files of interest:</p>
<ul>
  <li>main.py: nothing you wouldn’t expect. The only code of slight interest in there is how to run the 4 algorithms concurrently. All the rest is setup for PyGame, running the main “game loop”</li>
  <li>graph.py: contains an implementation of an undirected weighted graph, slightly tailored to the current problem at hand</li>
  <li>the folder /solvers contains the implementations of the 4 algorithms. The rest of the article will mostly focus on those</li>
</ul>

<h3 id="processing-the-results">Processing the results</h3>
<p>As stated earlier, the main.py file doesn’t contain much regarding the actual problem. However, maybe one little thing to touch on is how the 4 algorithms are executed concurrently, and results are processed as they come in.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">algorithms</span> <span class="o">=</span> <span class="p">[</span><span class="n">algorithm</span> <span class="k">for</span> <span class="n">algorithm</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">__algorithms</span>
              <span class="k">if</span> <span class="n">algorithm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">]</span>
<span class="n">zipped</span> <span class="o">=</span> <span class="n">stream</span><span class="p">.</span><span class="n">ziplatest</span><span class="p">(</span><span class="o">*</span><span class="n">algorithms</span><span class="p">)</span>
<span class="n">merged</span> <span class="o">=</span> <span class="n">stream</span><span class="p">.</span><span class="nb">map</span><span class="p">(</span><span class="n">zipped</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="k">async</span> <span class="k">with</span> <span class="n">merged</span><span class="p">.</span><span class="n">stream</span><span class="p">()</span> <span class="k">as</span> <span class="n">streamer</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">for</span> <span class="n">resultset</span> <span class="ow">in</span> <span class="n">streamer</span><span class="p">:</span>

</code></pre></div></div>

<p>To explain what goes on there, we’ll consider the following simple example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">aiostream</span> <span class="kn">import</span> <span class="n">stream</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">process_results_interleaved</span><span class="p">(</span><span class="n">races</span><span class="p">):</span>
    <span class="n">combine</span> <span class="o">=</span> <span class="n">stream</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="o">*</span><span class="n">races</span><span class="p">)</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">combine</span><span class="p">.</span><span class="n">stream</span><span class="p">()</span> <span class="k">as</span> <span class="n">streamer</span><span class="p">:</span>
        <span class="k">async</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">streamer</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">process_results_packet</span><span class="p">(</span><span class="n">races</span><span class="p">):</span>
    <span class="n">zipped</span> <span class="o">=</span> <span class="n">stream</span><span class="p">.</span><span class="n">ziplatest</span><span class="p">(</span><span class="o">*</span><span class="n">races</span><span class="p">)</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="n">stream</span><span class="p">.</span><span class="nb">map</span><span class="p">(</span><span class="n">zipped</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">merged</span><span class="p">.</span><span class="n">stream</span><span class="p">()</span> <span class="k">as</span> <span class="n">streamer</span><span class="p">:</span>
        <span class="k">async</span> <span class="k">for</span> <span class="n">resultset</span> <span class="ow">in</span> <span class="n">streamer</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">resultset</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">race</span><span class="p">(</span><span class="n">racer</span><span class="p">,</span> <span class="n">sleep_time</span><span class="p">,</span> <span class="n">checkpoints</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">checkpoints</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">sleep_time</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">checkpoints</span><span class="p">:</span>
            <span class="k">yield</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">racer</span><span class="si">}</span><span class="s"> finished!"</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">racer</span><span class="si">}</span><span class="s"> hits checkpoint: </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s">"</span>


<span class="k">def</span> <span class="nf">create_races</span><span class="p">(</span><span class="n">checkpoints</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">race</span><span class="p">(</span><span class="s">"Turtle"</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">checkpoints</span><span class="p">),</span>
            <span class="n">race</span><span class="p">(</span><span class="s">"Hare"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">checkpoints</span><span class="p">),</span>
            <span class="n">race</span><span class="p">(</span><span class="s">"Dragster"</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">checkpoints</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">checkpoints</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"Starting race, processing results as they come in from each contestant:"</span><span class="p">)</span>
    <span class="n">races</span> <span class="o">=</span> <span class="n">create_races</span><span class="p">(</span><span class="n">checkpoints</span><span class="p">)</span>
    <span class="n">asyncio</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">process_results_interleaved</span><span class="p">(</span><span class="n">races</span><span class="p">))</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"Starting race, processing results in packets:"</span><span class="p">)</span>
    <span class="n">races</span> <span class="o">=</span> <span class="n">create_races</span><span class="p">(</span><span class="n">checkpoints</span><span class="p">)</span>
    <span class="n">asyncio</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">process_results_packet</span><span class="p">(</span><span class="n">races</span><span class="p">))</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div></div>

<p>Just go over the code real quick, and it’ll become pretty clear what the setup is. We’ll have a race between a turtle, a hare and a fancy dragster car. They go through a number of checkpoints, and moving from one to the next simply takes them some amount of time, clumsily simulated by sleeping for an amount of time in the loop where they go through the checkpoints. The turtle takes 2 seconds to go from a checkpoint to the next, the hare takes 1 second, and the racing car only takes 300ms. Easy.</p>

<p>The whole reason behind this little fantasy is to show you how to process the results of this contest as each contestant hits a checkpoint. I first show an update every time a racer hits a checkpoint, in process_results_interleaved. Then, in process_results_packet, you’ll see that you get the full set of results whenever any of the racers hits a checkpoint. The output looks like this:</p>

<p><img src="http://localhost:4000/assets/tsp/race_results.png" alt="race_results" /></p>

<p>The whole point of this is that I wanted a way to combine the results of several concurrently running asynchronous generators as they come in, and more importantly: identify exactly which result comes from which generator, without necessarily putting code in each specific generator to help with that identification. I wanted to keep the implementation of each algorithm focussed on what it’s supposed to do, and not tailor it to the fact that I want to use it in a scenario where I want to run several at the same time and compare them. That’s not a concern the algorithm needs to care for.</p>

<p>When you go and run the 4 different algorithms that will look for a solution to the TSP, you want to receive updates whenever some improvement is reached, or whenever something useful can be put on the screen, without polluting the generators with some identifying code to update the right result set. So the way it’s done in process_results_packet will be the method to use for running the 4 TSP algorithms together. I’ll just put the 4 algorithms in an array, start them all at the same time, and every time any one of them yields a result, I get a dictionary back with the updated results. It’s these few lines that do the trick:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">zipped</span> <span class="o">=</span> <span class="n">stream</span><span class="p">.</span><span class="n">ziplatest</span><span class="p">(</span><span class="o">*</span><span class="n">races</span><span class="p">)</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="n">stream</span><span class="p">.</span><span class="nb">map</span><span class="p">(</span><span class="n">zipped</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">merged</span><span class="p">.</span><span class="n">stream</span><span class="p">()</span> <span class="k">as</span> <span class="n">streamer</span><span class="p">:</span>
        <span class="p">...</span>
</code></pre></div></div>

<p>Quite simple, and quite powerful. Ok, let’s get to the interesting parts now!</p>

<h3 id="a-brute-force-approach">A brute force approach</h3>
<p>Whenever you start implementing a non-trivial algorithm, it’s always a good idea to start with an implementation that is focussed on getting the correct result, disregarding any tendency you might have to go for early optimizations. Make it as simple and clear as you can, but focus on achieving a 100% correct solution. Explore the full set of possible solutions, perform an exhaustive search and simply keep updating the candidate solution every time there’s an improvement until there are no more candidate solutions, and you just found yourself the optimal solution. It will help you understand the problem, and you can use this initial iteration as a reference to compare future solutions with, and doublecheck them for correctness.</p>

<p>In case of the TSP, implementing a brute force solution is quite easy. We simply generate all possible permutations of the set of destinations, evaluate the full path distance from start through all nodes back to the initial node, and store the optimal path length and the sequence of nodes traveled in order to achieve it. Contrary to what I just said a sentence or 2 ago, I’d say some small optimizations are permitted. One such obvious thing is that a sequence of A - B - C - A is identical in length to the sequence A - C - B - A, and as such, both do not need to be evaluated. We only consider unique permutations. We obviously don’t need to continuously build the actual graph under consideration for the algorithm to work. However, I wanted to display the paths under evaluation as the algorithm does its work, so that little bit of extra effort is worth it for this project.</p>

<p>If you check the <a href="https://youtu.be/XCZSwM--vCA" target="_blank">clip</a> I linked before, you will see that during each iteration, a new path permutation (the lines in white) is being evaluated. Whenever a path is shorter than the known shortest path, that path is updated and shown in green. If you want to follow along with a bit more detail, just change the sleeping time at the end of the for-loop to something that gives you a bit more time to realize what’s occurring.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">def</span> <span class="nf">brute_force</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="n">AlgorithmResult</span><span class="p">]:</span>
    <span class="s">"""Solve the TSP problem with a brute force implementation, running through all permutations"""</span>
    <span class="n">unique_permutations</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">paths_evaluated</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">evaluations_until_solved</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">key</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">sub_keys</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">for</span> <span class="n">permutation</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">(</span><span class="n">sub_keys</span><span class="p">):</span>
        <span class="n">permutation</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span><span class="p">,)</span> <span class="o">+</span> <span class="n">permutation</span> <span class="o">+</span> <span class="p">(</span><span class="n">start</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">permutation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unique_permutations</span> <span class="ow">and</span> <span class="n">permutation</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unique_permutations</span><span class="p">:</span>
            <span class="n">paths_evaluated</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">unique_permutations</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span>
            <span class="n">current_path_length</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">start</span>
            <span class="n">vertices</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">permutation</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">distance</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">)]</span>
                <span class="n">current_path_length</span> <span class="o">+=</span> <span class="n">distance</span>
                <span class="n">vertices</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">distance</span><span class="p">))</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">key</span>

            <span class="n">graph</span><span class="p">.</span><span class="n">remove_vertices</span><span class="p">()</span>
            <span class="n">graph</span><span class="p">.</span><span class="n">add_vertices</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">current_path_length</span> <span class="o">&lt;</span> <span class="n">graph</span><span class="p">.</span><span class="n">optimal_cycle_length</span><span class="p">:</span>
                <span class="n">graph</span><span class="p">.</span><span class="n">optimal_cycle</span> <span class="o">=</span> <span class="n">ShortestPath</span><span class="p">(</span><span class="n">current_path_length</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>
                <span class="n">evaluations_until_solved</span> <span class="o">=</span> <span class="n">paths_evaluated</span>
            <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.0001</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">AlgorithmResult</span><span class="p">(</span><span class="n">paths_evaluated</span><span class="p">,</span> <span class="n">evaluations_until_solved</span><span class="p">)</span>

    <span class="n">graph</span><span class="p">.</span><span class="n">remove_vertices</span><span class="p">()</span>
    <span class="n">graph</span><span class="p">.</span><span class="n">add_vertices</span><span class="p">(</span><span class="n">graph</span><span class="p">.</span><span class="n">optimal_cycle</span><span class="p">.</span><span class="n">vertices</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">AlgorithmResult</span><span class="p">(</span><span class="n">paths_evaluated</span><span class="p">,</span> <span class="n">evaluations_until_solved</span><span class="p">)</span>
</code></pre></div></div>

<p>And there you have it. Problem solved! Well, kind of. For an ideal path between, let’s say, 5 or so points, I guess this brute force approach is still ok. You’ll notice, though, that when you have 8 or more points, things become very painful. Since we check all permutations, the runtime of the brute force algorithm is N! since we want to consider every possible vertex between each pair of nodes. Quite horrific, but at least we now have a way to test other, more optimal solutions for correctness.</p>

<h3 id="dynamic-programming-to-the-rescue">Dynamic programming to the rescue</h3>

<p>That brings us to an approach we’ve all used as a first optimization to so many algorithmic problems: dynamic programming. That will bring the time complexity down from O(n!) to O(n²2n). For the more curious readers that couldn’t help but scroll down instead of reading this: you’ve noticed that this requires quite a bit more code than our naive brute force approach. This already hammers home the statement about not diving into optimization too early. It’s easy to make a small little mistake, and depending on how involved of a solution you start to implement beyond brute force tactics, it can be quite cumbersome to debug.</p>

<p>The specific implementation I went for is one such example. As often when using dynamic programming, memoization is a big help here. But not only that, you also notice some bit-wise operations going on to further improve the speed of this solution. I will explain the steps we go through in this approach as best as I can.</p>

<p>The overall approach here, is that we will no longer consider all possible full paths through the set of nodes until we find the shortest one. As we do in dynamic programming, we solve a subset of the problem, and keep expanding on it until we find a solution to the full problem. During this expansion, we use previously achieved results to avoid doing double work, using memoization. Here’s the full code (for all you copy-paste problem solvers out there ;-) ), read through it, and then I’ll focus on some specific parts. Just in case dynamic programming is a new concept to you, check out some articles or video tutorials online, maybe comparing greedy algorithms to dynamic programming for problems like the knapsack problem or coin change problem. That should help you to get it down. The full code:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">def</span> <span class="nf">dynamic_programming</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span>
                              <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="n">AlgorithmResult</span><span class="p">]:</span>
    <span class="s">"""Solve the TSP problem with dynamic programming"""</span>
    <span class="n">node_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">key</span>
    <span class="n">memo</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">node_count</span><span class="p">)]</span> <span class="k">for</span> <span class="n">__</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">)]</span>
    <span class="n">optimal_cycle</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">optimal_cycle_length</span> <span class="o">=</span> <span class="n">maxsize</span>
    <span class="n">cycles_evaluated</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">evaluations_until_solved</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">memo</span> <span class="o">=</span> <span class="n">setup</span><span class="p">(</span><span class="n">memo</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">nodes_in_subcycle</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">node_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">subcycle</span> <span class="ow">in</span> <span class="n">initialize_combinations</span><span class="p">(</span><span class="n">nodes_in_subcycle</span><span class="p">,</span> <span class="n">node_count</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_not_in</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">subcycle</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">cycles_evaluated</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Look for the best next node to attach to the cycle
</span>            <span class="k">for</span> <span class="n">next_node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">next_node</span> <span class="o">==</span> <span class="n">start</span> <span class="ow">or</span> <span class="n">is_not_in</span><span class="p">(</span><span class="n">next_node</span><span class="p">,</span> <span class="n">subcycle</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="n">subcycle_without_next_node</span> <span class="o">=</span> <span class="n">subcycle</span> <span class="o">^</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">next_node</span><span class="p">)</span>
                <span class="n">min_cycle_length</span> <span class="o">=</span> <span class="n">maxsize</span>
                <span class="k">for</span> <span class="n">last_node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">last_node</span> <span class="o">==</span> <span class="n">start</span> <span class="ow">or</span> <span class="n">last_node</span> <span class="o">==</span> <span class="n">next_node</span> <span class="ow">or</span> <span class="n">is_not_in</span><span class="p">(</span><span class="n">last_node</span><span class="p">,</span> <span class="n">subcycle</span><span class="p">)):</span>
                        <span class="k">continue</span>

                    <span class="n">new_cycle_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">memo</span><span class="p">[</span><span class="n">last_node</span><span class="p">][</span><span class="n">subcycle_without_next_node</span><span class="p">]</span> <span class="o">+</span> <span class="n">distances</span><span class="p">[(</span><span class="n">last_node</span><span class="p">,</span> <span class="n">next_node</span><span class="p">)])</span>
                    <span class="k">if</span> <span class="n">new_cycle_length</span> <span class="o">&lt;</span> <span class="n">min_cycle_length</span><span class="p">:</span>
                        <span class="n">min_cycle_length</span> <span class="o">=</span> <span class="n">new_cycle_length</span>
                    <span class="n">memo</span><span class="p">[</span><span class="n">next_node</span><span class="p">][</span><span class="n">subcycle</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_cycle_length</span>

        <span class="n">evaluations_until_solved</span> <span class="o">=</span> <span class="n">cycles_evaluated</span>
        <span class="n">optimal_cycle_length</span> <span class="o">=</span> <span class="n">calculate_optimal_cycle_length</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">nodes_in_subcycle</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
        <span class="n">optimal_cycle</span> <span class="o">=</span> <span class="n">find_optimal_cycle</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">nodes_in_subcycle</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">create_vertices</span><span class="p">(</span><span class="n">optimal_cycle</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
        <span class="n">graph</span><span class="p">.</span><span class="n">optimal_cycle</span> <span class="o">=</span> <span class="n">ShortestPath</span><span class="p">(</span><span class="n">optimal_cycle_length</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.0001</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">AlgorithmResult</span><span class="p">(</span><span class="n">cycles_evaluated</span><span class="p">,</span> <span class="n">evaluations_until_solved</span><span class="p">)</span>

    <span class="n">optimal_cycle_length</span> <span class="o">=</span> <span class="n">calculate_optimal_cycle_length</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">node_count</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
    <span class="n">optimal_cycle</span> <span class="o">=</span> <span class="n">find_optimal_cycle</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">node_count</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">create_vertices</span><span class="p">(</span><span class="n">optimal_cycle</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
    <span class="n">graph</span><span class="p">.</span><span class="n">remove_vertices</span><span class="p">()</span>
    <span class="n">graph</span><span class="p">.</span><span class="n">add_vertices</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
    <span class="n">graph</span><span class="p">.</span><span class="n">optimal_cycle</span> <span class="o">=</span> <span class="n">ShortestPath</span><span class="p">(</span><span class="n">optimal_cycle_length</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">AlgorithmResult</span><span class="p">(</span><span class="n">cycles_evaluated</span><span class="p">,</span> <span class="n">evaluations_until_solved</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="n">memo</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="s">"""Prepare the array used for memoization during the dynamic programming algorithm"""</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">node</span><span class="p">.</span><span class="n">key</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">memo</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">start</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[(</span><span class="n">start</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">memo</span>


<span class="k">def</span> <span class="nf">initialize_combinations</span><span class="p">(</span><span class="n">nodes_in_subcycle</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">node_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="s">"""Initialize the combinations to consider in the next step of the algorithm"""</span>
    <span class="n">subcycle_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">initialize_combination</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nodes_in_subcycle</span><span class="p">,</span> <span class="n">node_count</span><span class="p">,</span> <span class="n">subcycle_list</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">subcycle_list</span>


<span class="k">def</span> <span class="nf">initialize_combination</span><span class="p">(</span><span class="n">subcycle</span><span class="p">,</span> <span class="n">at</span><span class="p">,</span> <span class="n">nodes_in_subcycle</span><span class="p">,</span> <span class="n">node_count</span><span class="p">,</span> <span class="n">subcycle_list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="s">"""Initialize the combination to consider in the next step of the algorithm"""</span>
    <span class="n">elements_left_to_pick</span> <span class="o">=</span> <span class="n">node_count</span> <span class="o">-</span> <span class="n">at</span>
    <span class="k">if</span> <span class="n">elements_left_to_pick</span> <span class="o">&lt;</span> <span class="n">nodes_in_subcycle</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="n">nodes_in_subcycle</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">subcycle_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">subcycle</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="n">node_count</span><span class="p">):</span>
            <span class="n">subcycle</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span>
            <span class="n">initialize_combination</span><span class="p">(</span><span class="n">subcycle</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nodes_in_subcycle</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                   <span class="n">node_count</span><span class="p">,</span> <span class="n">subcycle_list</span><span class="p">)</span>
            <span class="n">subcycle</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_not_in</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">subcycle</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="s">"""Checks if the bit at the given index is a 0"""</span>
    <span class="k">return</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">subcycle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">calculate_optimal_cycle_length</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">node_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">memo</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                                   <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="s">"""Calculate the optimal cycle length"""</span>
    <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">node_count</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">optimal_cycle_length</span> <span class="o">=</span> <span class="n">maxsize</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">start</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">cycle_cost</span> <span class="o">=</span> <span class="n">memo</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">end</span><span class="p">]</span> <span class="o">+</span> <span class="n">distances</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">start</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">cycle_cost</span> <span class="o">&lt;</span> <span class="n">optimal_cycle_length</span><span class="p">:</span>
            <span class="n">optimal_cycle_length</span> <span class="o">=</span> <span class="n">cycle_cost</span>

    <span class="k">return</span> <span class="n">optimal_cycle_length</span>


<span class="k">def</span> <span class="nf">find_optimal_cycle</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">node_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">memo</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                       <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]):</span>
    <span class="s">"""Recreate the optimal cycle"""</span>
    <span class="n">last_index</span> <span class="o">=</span> <span class="n">start</span>
    <span class="n">state</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">node_count</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">optimal_cycle</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">start</span> <span class="ow">or</span> <span class="n">is_not_in</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">j</span>
            <span class="n">prev_cycle_length</span> <span class="o">=</span> <span class="n">memo</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">state</span><span class="p">]</span> <span class="o">+</span> <span class="n">distances</span><span class="p">[(</span><span class="n">index</span><span class="p">,</span> <span class="n">last_index</span><span class="p">)]</span>
            <span class="n">new_cycle_length</span> <span class="o">=</span> <span class="n">memo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">state</span><span class="p">]</span> <span class="o">+</span> <span class="n">distances</span><span class="p">[(</span><span class="n">j</span><span class="p">,</span> <span class="n">last_index</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">new_cycle_length</span> <span class="o">&lt;</span> <span class="n">prev_cycle_length</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">j</span>

        <span class="n">optimal_cycle</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">state</span> <span class="o">^</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">)</span>
        <span class="n">last_index</span> <span class="o">=</span> <span class="n">index</span>
    <span class="n">optimal_cycle</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="n">optimal_cycle</span><span class="p">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="n">optimal_cycle</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">optimal_cycle</span>


<span class="k">def</span> <span class="nf">create_vertices</span><span class="p">(</span><span class="n">optimal_cycle</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span>
                    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
    <span class="s">"""Transform the list of visited node keys to something our graph can work with"""</span>
    <span class="n">vertices</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">optimal_cycle</span><span class="p">)):</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[(</span><span class="n">optimal_cycle</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">optimal_cycle</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
        <span class="n">vertices</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">optimal_cycle</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">optimal_cycle</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">weight</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">vertices</span>
</code></pre></div></div>

<p>Again, in case you want to understand the steps on a high level, change the sleep time to about a second or so, and you will see what happens. Starting with a cycle of 2 nodes, building up to a cycle including all the points, we find the shortest possible path using the points we include in the cycle. Whenever an optimal solution is found for 3 points, we find an optimal solution for those 2 points plus 1 more, re-using what we already learned so far. We keep doing that until the full set of nodes has been traveled. It’s really quite beautiful to see in action, in my opinion. How to achieve it though?</p>

<h4 id="getting-the-memoization-matrix-set-up">Getting the memoization matrix set up</h4>

<p>We start out with preparing our memoization matrix:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">memo</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">node_count</span><span class="p">)]</span> <span class="k">for</span> <span class="n">__</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">)]</span>
<span class="p">...</span>
<span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="n">memo</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">node</span><span class="p">.</span><span class="n">key</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">memo</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">start</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[(</span><span class="n">start</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">memo</span>
</code></pre></div></div>

<p>Here, I create a matrix with a number of rows equal to the amount of nodes we have, and the columns equaling 2 to the power of the amount of nodes. So for 5 nodes, that’s a 5x32 matrix. As you may know, raising 2 to the power of N equals shifting a 1-bit to the left N times, since a move to the left doubles the binary value. It’s just faster using bit shifting, simple as that. We loop through each node, skipping the start node, and we store the optimal distance from athe start node to each other node.</p>

<h4 id="other-helper-functions">Other helper functions</h4>

<p>Besides the preparation of the memoization matrix, other functions such as, find_optimal_cycle and create_vertices are actually not terribly complicated or interesting. If we keep in mind that, during dynamic programming, we build on top of earlier achieved results (optimal paths through n nodes) to get the optimal result for n+1 nodes, it’s not hard to imagine we will need to consider a new set of cycles and nodes to evaluate whether adding a certain node to our cycle yields a more optimal results than adding another. Beyond that, in the visualization of the brute force algorithm you noticed we keep on drawing the vertices under consideration. For the dynamic programming solution, we simply want to build the new optimal cycle and put it on the screen, so we have some functions for that. Stepping through them with a small amount of nodes will make it very clear what they do. Be sure to brush off those bit manipulator operations first ;-)</p>

<h4 id="just-one-more-thing">Just one more thing</h4>
<p>Maybe a bit of explanation on the initialize_combinations and initialize_combination methods: initialize_combinations will fill the subcycle_list variable using the initialize_combination method, that much is obvious. initialize_combination is a recursive method to generate bit sets, starting from an empty set (0). From an empty set, we want to set nodes_in_subcycle out of node_count bits to be 1 for all possible combinations. We keep track of which index position we’re at (indicated by variable i), try to set it to 1 and keep moving forward. At the end of that, we should have exactly node_count bits. If we don’t, we backtrack and flip off (not like that) the i-th bit and move to the next position. This is a classic backtracking problem and if you want to learn more about this, look for backtracking tutorials for power sets.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize_combinations</span><span class="p">(</span><span class="n">nodes_in_subcycle</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">node_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="s">"""Initialize the combinations to consider in the next step of the algorithm"""</span>
    <span class="n">subcycle_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">initialize_combination</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nodes_in_subcycle</span><span class="p">,</span> <span class="n">node_count</span><span class="p">,</span> <span class="n">subcycle_list</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">subcycle_list</span>


<span class="k">def</span> <span class="nf">initialize_combination</span><span class="p">(</span><span class="n">subcycle</span><span class="p">,</span> <span class="n">at</span><span class="p">,</span> <span class="n">nodes_in_subcycle</span><span class="p">,</span> <span class="n">node_count</span><span class="p">,</span> <span class="n">subcycle_list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="s">"""Initialize the combination to consider in the next step of the algorithm"""</span>
    <span class="n">elements_left_to_pick</span> <span class="o">=</span> <span class="n">node_count</span> <span class="o">-</span> <span class="n">at</span>
    <span class="k">if</span> <span class="n">elements_left_to_pick</span> <span class="o">&lt;</span> <span class="n">nodes_in_subcycle</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="n">nodes_in_subcycle</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">subcycle_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">subcycle</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="n">node_count</span><span class="p">):</span>
            <span class="n">subcycle</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span>
            <span class="n">initialize_combination</span><span class="p">(</span><span class="n">subcycle</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nodes_in_subcycle</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                   <span class="n">node_count</span><span class="p">,</span> <span class="n">subcycle_list</span><span class="p">)</span>
            <span class="n">subcycle</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="solving-the-puzzle">Solving the puzzle</h4>

<p>This is where the actual work happens, and there’s a bit to it. Make sure the other functions are clear to you, and the use of a memoization matrix in dynamic programming in general is a concept you understand.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span> <span class="n">nodes_in_subcycle</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">node_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">subcycle</span> <span class="ow">in</span> <span class="n">initialize_combinations</span><span class="p">(</span><span class="n">nodes_in_subcycle</span><span class="p">,</span> <span class="n">node_count</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_not_in</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">subcycle</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">cycles_evaluated</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Look for the best next node to attach to the cycle
</span>            <span class="k">for</span> <span class="n">next_node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">next_node</span> <span class="o">==</span> <span class="n">start</span> <span class="ow">or</span> <span class="n">is_not_in</span><span class="p">(</span><span class="n">next_node</span><span class="p">,</span> <span class="n">subcycle</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="n">subcycle_without_next_node</span> <span class="o">=</span> <span class="n">subcycle</span> <span class="o">^</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">next_node</span><span class="p">)</span>
                <span class="n">min_cycle_length</span> <span class="o">=</span> <span class="n">maxsize</span>
                <span class="k">for</span> <span class="n">last_node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">last_node</span> <span class="o">==</span> <span class="n">start</span> <span class="ow">or</span> <span class="n">last_node</span> <span class="o">==</span> <span class="n">next_node</span> <span class="ow">or</span> <span class="n">is_not_in</span><span class="p">(</span><span class="n">last_node</span><span class="p">,</span> <span class="n">subcycle</span><span class="p">)):</span>
                        <span class="k">continue</span>

                    <span class="n">new_cycle_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">memo</span><span class="p">[</span><span class="n">last_node</span><span class="p">][</span><span class="n">subcycle_without_next_node</span><span class="p">]</span> <span class="o">+</span> <span class="n">distances</span><span class="p">[(</span><span class="n">last_node</span><span class="p">,</span> <span class="n">next_node</span><span class="p">)])</span>
                    <span class="k">if</span> <span class="n">new_cycle_length</span> <span class="o">&lt;</span> <span class="n">min_cycle_length</span><span class="p">:</span>
                        <span class="n">min_cycle_length</span> <span class="o">=</span> <span class="n">new_cycle_length</span>
                    <span class="n">memo</span><span class="p">[</span><span class="n">next_node</span><span class="p">][</span><span class="n">subcycle</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_cycle_length</span>

        <span class="n">evaluations_until_solved</span> <span class="o">=</span> <span class="n">cycles_evaluated</span>
        <span class="n">optimal_cycle_length</span> <span class="o">=</span> <span class="n">calculate_optimal_cycle_length</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">nodes_in_subcycle</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
        <span class="n">optimal_cycle</span> <span class="o">=</span> <span class="n">find_optimal_cycle</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">nodes_in_subcycle</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">create_vertices</span><span class="p">(</span><span class="n">optimal_cycle</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
        <span class="n">graph</span><span class="p">.</span><span class="n">optimal_cycle</span> <span class="o">=</span> <span class="n">ShortestPath</span><span class="p">(</span><span class="n">optimal_cycle_length</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.0001</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">AlgorithmResult</span><span class="p">(</span><span class="n">cycles_evaluated</span><span class="p">,</span> <span class="n">evaluations_until_solved</span><span class="p">)</span>
</code></pre></div></div>

<p>As you can see, the outer loop increases the length of the cycle by 1 each iteration. In every iteration, we find the optimal cycle of a certain length, as we increase the cycle length until we have an optimal cycle equal to the amount of nodes. The first inner loop goes over all distinct subcycles we want to consider. Obviously, we only want to consider subcycles where the start node is actually part of the subcycle. Otherwise, that subcycle could not have started at the starting node. The function to check that is called is_not_in:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">is_not_in</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">subcycle</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="s">"""Checks if the bit at the given index is a 0"""</span>
    <span class="k">return</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">subcycle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
</code></pre></div></div>
<p>and all that’s done here is check whether or not the bit at the index position in the subcycle is a 0. If it is, the node is not part of the subcycle.</p>

<p>After that, we loop over all potential next nodes. Here, we only want to consider nodes that are actually in the subcycle, and are not equal to our starting node. We then represent the next subcycle without this next node. We do this so we can use our memoization matrix to look up what the best partial tour length was without the next node already included. The last inner loop, where we cycle the last_node variable over the range of possible nodes, is there to to test all possible end nodes of the currently considered subcycle, and consider which node best optimizes that subcycle. This last node can of course not be the start node, next node that is fixed in the loop before, and should obviously be part of the current subcycle.</p>

<p>Per potential new last node, we check if the cost of the cycle with this last node is better than the currently known lowest cost (or shortest distance in our case). If so, we set the new min_cycle_length and store the best subcycle in the memoization matrix.</p>

<p>At the end of each new subcycle length, we do some bookkeeping and a little bit of work to reconstruct the actual newly found shortest cycle of length nodes_in_subcycle, and yield that back so it can be displayed on screen. The functions calculate_optimal_cycle_length and find_optimal_cycle are responsible for this. If you are familiar with dynamic programming, reconstructing a solution from a memoization table will be familiar to you. The only bit of added complexity here is that this reconstruction is done using our bitmasks in the memoization table.</p>

<p>And that does it. If this is not entirely clear, I recommend you to make sure the basics of dynamic programming and bit-wise operators are under your belt, and simply step through the code using a graph with 5 or so nodes. That allows you to still reason about the whole concept and actually follow along what is happening.</p>

<h4 id="beware-python-looping">Beware Python looping</h4>

<p>A final word of warning if you play around with this yourself: there’s quite a bit of looping going on in this implementation. Normally, that would be no issue. Python, however, is notoriously slow when it comes to looping. In my previous post about the <a href="https://www.peculiar-coding-endeavours.com/2023/game-of-life/" target="_blank">Game of Life</a>, I tackled that problem by using Numpy, Numba, and some search space optimizations. I decided not to take that route this time however, since I didn’t want to make the implementation even more complex, and also give a fair comparison of all 4 algorithms without any trickery going into it. I will probably make a Rust 🦀 version at some point, probably without too many visuals going on (unless I get good at Bevy real fast), so the raw performance potential of several algorithms is more obvious. For now though, bear with me (or Python rather). I don’t execute the brute force and dynamic programming algorithms when the amount of nodes exceeds 8 and 17 nodes respectively, so things won’t be overly painful.</p>

<h3 id="genetic-algorithm">Genetic algorithm</h3>

<p>Finally, this is where the real fun starts… Now that we have 2 ways of solving the TSP that give us a guaranteed optimal result, even though it might take a bit to get there, we’ll dig into some approximation algorithms. Firstly, genetic algorithms. You will see that the code isn’t terribly complex at all, which allows me to focus on the high level concepts of these interesting algorithms and apply them on this problem. If the dynamic programming section was a bit of a head-scratcher: no worries, it’s all fun from here on out.</p>

<p>First and foremost: what are genetic algorithms..?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">def</span> <span class="nf">genetic_algorithm</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span> <span class="n">population_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                            <span class="n">max_generations</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">max_no_improvement</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="n">AlgorithmResult</span><span class="p">]:</span>
    <span class="s">"""Solve the TSP problem with a genetic algorithm"""</span>
    <span class="n">generations_evaluated</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">generations_until_solved</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">generations_without_improvement</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">optimal_cycle</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">optimal_cycle_length</span> <span class="o">=</span> <span class="n">maxsize</span>
    <span class="n">population</span> <span class="o">=</span> <span class="n">spawn</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">population_size</span><span class="p">)</span>
    <span class="n">cycle_lengths</span> <span class="o">=</span> <span class="n">get_cycle_lengths</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_generations</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">generations_without_improvement</span> <span class="o">&gt;=</span> <span class="n">max_no_improvement</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="n">fitness</span> <span class="o">=</span> <span class="n">determine_fitness</span><span class="p">(</span><span class="n">cycle_lengths</span><span class="p">)</span>
        <span class="n">improved</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cycle_length</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cycle_lengths</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cycle_length</span> <span class="o">&lt;</span> <span class="n">optimal_cycle_length</span><span class="p">:</span>
                <span class="n">improved</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">optimal_cycle_length</span> <span class="o">=</span> <span class="n">cycle_length</span>
                <span class="n">optimal_cycle</span> <span class="o">=</span> <span class="n">population</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">generations_evaluated</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">improved</span><span class="p">:</span>
            <span class="n">generations_until_solved</span> <span class="o">=</span> <span class="n">generations_evaluated</span>
            <span class="n">generations_without_improvement</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">vertices</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">optimal_cycle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">optimal_cycle</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">distance</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">)]</span>
                <span class="n">vertices</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">distance</span><span class="p">))</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">key</span>
            <span class="n">graph</span><span class="p">.</span><span class="n">remove_vertices</span><span class="p">()</span>
            <span class="n">graph</span><span class="p">.</span><span class="n">add_vertices</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
            <span class="n">graph</span><span class="p">.</span><span class="n">optimal_cycle</span> <span class="o">=</span> <span class="n">ShortestPath</span><span class="p">(</span><span class="n">optimal_cycle_length</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">generations_without_improvement</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">population</span><span class="p">,</span> <span class="n">cycle_lengths</span> <span class="o">=</span> <span class="n">create_next_population</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">cycle_lengths</span><span class="p">,</span>
                                                           <span class="n">fitness</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.0001</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">AlgorithmResult</span><span class="p">(</span><span class="n">generations_evaluated</span><span class="p">,</span> <span class="n">generations_until_solved</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">AlgorithmResult</span><span class="p">(</span><span class="n">generations_evaluated</span><span class="p">,</span> <span class="n">generations_until_solved</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">spawn</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">population_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="s">"""Create the initial generation"""</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">key</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">max_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">factorial</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">unique_permutations</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_permutations</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">population_size</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_permutations</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_size</span><span class="p">:</span>
        <span class="n">permutation</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
        <span class="n">shuffle</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span>
        <span class="n">permutation</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">start</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">permutation</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unique_permutations</span><span class="p">:</span>
            <span class="n">unique_permutations</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span> <span class="k">for</span> <span class="n">permutation</span> <span class="ow">in</span> <span class="n">unique_permutations</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">create_next_population</span><span class="p">(</span><span class="n">current_population</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">cycle_lengths</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                           <span class="n">fitness</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span>
                           <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="s">"""Create the next generation"""</span>
    <span class="n">new_population</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">population_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_population</span><span class="p">)</span>

    <span class="c1"># Create the offspring of the current generation
</span>    <span class="n">offspring</span> <span class="o">=</span> <span class="n">create_offspring</span><span class="p">(</span><span class="n">current_population</span><span class="p">,</span> <span class="n">fitness</span><span class="p">,</span> <span class="n">population_size</span><span class="p">)</span>

    <span class="c1"># Perform a variation of elitism where we add the offspring to the current generation
</span>    <span class="c1"># and only continue with the fittest list of size population_size
</span>    <span class="n">new_population</span> <span class="o">=</span> <span class="n">current_population</span> <span class="o">+</span> <span class="n">offspring</span>
    <span class="n">offspring_cycle_lengths</span> <span class="o">=</span> <span class="n">get_cycle_lengths</span><span class="p">(</span><span class="n">offspring</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
    <span class="n">new_population_cycle_lengths</span> <span class="o">=</span> <span class="n">cycle_lengths</span> <span class="o">+</span> <span class="n">offspring_cycle_lengths</span>
    <span class="n">new_population_fitness</span> <span class="o">=</span> <span class="n">fitness</span> <span class="o">+</span> <span class="n">determine_fitness</span><span class="p">(</span><span class="n">offspring_cycle_lengths</span><span class="p">)</span>
    <span class="n">survivor_candidates</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_population_fitness</span><span class="p">,</span> <span class="n">new_population</span><span class="p">)</span>
    <span class="n">fittest_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">heapq</span><span class="p">.</span><span class="n">nlargest</span><span class="p">(</span><span class="n">population_size</span><span class="p">,</span> <span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">survivor_candidates</span><span class="p">)))]</span>
    <span class="n">new_population</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_population</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fittest_indices</span><span class="p">]</span>
    <span class="n">new_population_cycle_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_population_cycle_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fittest_indices</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">new_population</span><span class="p">,</span> <span class="n">new_population_cycle_lengths</span>


<span class="k">def</span> <span class="nf">create_offspring</span><span class="p">(</span><span class="n">current_population</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">fitness</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                     <span class="n">population_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="s">"""Create a new generation"""</span>
    <span class="n">offspring</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">offspring</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">population_size</span><span class="p">:</span>
        <span class="n">parent1</span> <span class="o">=</span> <span class="n">parent2</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">parent1</span> <span class="o">==</span> <span class="n">parent2</span><span class="p">:</span>
            <span class="n">parent1</span> <span class="o">=</span> <span class="n">get_parent</span><span class="p">(</span><span class="n">fitness</span><span class="p">)</span>
            <span class="n">parent2</span> <span class="o">=</span> <span class="n">get_parent</span><span class="p">(</span><span class="n">fitness</span><span class="p">)</span>

        <span class="n">child1</span> <span class="o">=</span> <span class="n">crossover</span><span class="p">(</span><span class="n">current_population</span><span class="p">[</span><span class="n">parent1</span><span class="p">],</span> <span class="n">current_population</span><span class="p">[</span><span class="n">parent2</span><span class="p">])</span>
        <span class="n">child2</span> <span class="o">=</span> <span class="n">crossover</span><span class="p">(</span><span class="n">current_population</span><span class="p">[</span><span class="n">parent2</span><span class="p">],</span> <span class="n">current_population</span><span class="p">[</span><span class="n">parent1</span><span class="p">])</span>

        <span class="n">child1</span> <span class="o">=</span> <span class="n">mutate</span><span class="p">(</span><span class="n">child1</span><span class="p">)</span>
        <span class="n">child2</span> <span class="o">=</span> <span class="n">mutate</span><span class="p">(</span><span class="n">child2</span><span class="p">)</span>

        <span class="n">offspring</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">child1</span><span class="p">)</span>
        <span class="n">offspring</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">child2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">offspring</span>


<span class="k">def</span> <span class="nf">get_parent</span><span class="p">(</span><span class="n">fitness</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]):</span>
    <span class="s">"""Get a parent using either tournament selection or biased random selection"""</span>
    <span class="k">if</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tournament_selection</span><span class="p">(</span><span class="n">fitness</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">biased_random_selection</span><span class="p">(</span><span class="n">fitness</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">tournament_selection</span><span class="p">(</span><span class="n">fitness</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="s">"""Perform basic tournament selection to get a parent"""</span>
    <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fitness</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">candidate1</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
    <span class="n">candidate2</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">candidate1</span> <span class="o">==</span> <span class="n">candidate2</span><span class="p">:</span>
        <span class="n">candidate2</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">candidate1</span> <span class="k">if</span> <span class="n">fitness</span><span class="p">[</span><span class="n">candidate1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">fitness</span><span class="p">[</span><span class="n">candidate2</span><span class="p">]</span> <span class="k">else</span> <span class="n">candidate2</span>


<span class="k">def</span> <span class="nf">biased_random_selection</span><span class="p">(</span><span class="n">fitness</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="s">"""Perform biased random selection to get a parent"""</span>
    <span class="n">random_specimen</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fitness</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fitness</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fitness</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">fitness</span><span class="p">[</span><span class="n">random_specimen</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">i</span>

    <span class="k">return</span> <span class="n">random_specimen</span>


<span class="k">def</span> <span class="nf">crossover</span><span class="p">(</span><span class="n">parent1</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">parent2</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="s">"""Cross-breed a new set of children from the given parents"""</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">parent1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">parent1</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">parent1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">parent1</span> <span class="o">=</span> <span class="n">parent1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">parent1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">parent2</span> <span class="o">=</span> <span class="n">parent2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">parent2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">split</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">child</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">split</span><span class="p">):</span>
        <span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="n">remainder</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">parent2</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">child</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">remainder</span><span class="p">):</span>
        <span class="n">child</span><span class="p">[</span><span class="n">split</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">start</span><span class="p">,</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="n">end</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">mutate</span><span class="p">(</span><span class="n">child</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="s">"""Mutate the child sequence"""</span>
    <span class="k">if</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">child</span> <span class="o">=</span> <span class="n">swap_mutate</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
    <span class="n">child</span> <span class="o">=</span> <span class="n">rotate_mutate</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">child</span>


<span class="k">def</span> <span class="nf">swap_mutate</span><span class="p">(</span><span class="n">child</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="s">"""Mutate the cycle by swapping 2 nodes"""</span>
    <span class="n">index1</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">index2</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">child</span><span class="p">[</span><span class="n">index1</span><span class="p">],</span> <span class="n">child</span><span class="p">[</span><span class="n">index2</span><span class="p">]</span> <span class="o">=</span> <span class="n">child</span><span class="p">[</span><span class="n">index2</span><span class="p">],</span> <span class="n">child</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">child</span>


<span class="k">def</span> <span class="nf">rotate_mutate</span><span class="p">(</span><span class="n">child</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="s">"""Mutate the cycle by rotating a part nodes"""</span>
    <span class="n">split</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">split</span><span class="p">]</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="n">child</span><span class="p">[</span><span class="n">split</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">tail</span> <span class="o">=</span> <span class="n">child</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="n">child</span> <span class="o">=</span> <span class="n">head</span> <span class="o">+</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">tail</span>

    <span class="k">return</span> <span class="n">child</span>


<span class="k">def</span> <span class="nf">get_cycle_lengths</span><span class="p">(</span><span class="n">population</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
                      <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="s">"""Get the lengths of all cycles in the graph"""</span>
    <span class="n">cycle_lengths</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">specimen</span> <span class="ow">in</span> <span class="n">population</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">specimen</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cycle_length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">specimen</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">cycle_length</span> <span class="o">+=</span> <span class="n">distances</span><span class="p">[(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">)]</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">key</span>
        <span class="n">cycle_lengths</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">cycle_length</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cycle_lengths</span>


<span class="k">def</span> <span class="nf">determine_fitness</span><span class="p">(</span><span class="n">cycle_lengths</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
    <span class="s">"""Determine the fitness of the specimens in the population"""</span>
    <span class="c1"># Invert so that shorter paths get higher values
</span>    <span class="n">fitness_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cycle_lengths</span><span class="p">)</span>
    <span class="n">fitness</span> <span class="o">=</span> <span class="p">[</span><span class="n">fitness_sum</span> <span class="o">/</span> <span class="n">cycle_length</span> <span class="k">for</span> <span class="n">cycle_length</span> <span class="ow">in</span> <span class="n">cycle_lengths</span><span class="p">]</span>

    <span class="c1"># Normalize the fitness
</span>    <span class="n">fitness_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">fitness</span><span class="p">)</span>
    <span class="n">fitness</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="o">/</span> <span class="n">fitness_sum</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fitness</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">fitness</span>
</code></pre></div></div>

<h3 id="thousands-of-little-creepers">Thousands of little creepers…</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">def</span> <span class="nf">ant_colony</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span>
                     <span class="n">max_swarms</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">max_no_improvement</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="n">AlgorithmResult</span><span class="p">]:</span>
    <span class="s">"""Solve the TSP problem using ant colony optimization"""</span>
    <span class="n">swarms_evaluated</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">evaluations_until_solved</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">swarms_without_improvement</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">node_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">.</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">pheromones</span> <span class="o">=</span> <span class="n">initialize_pheromones</span><span class="p">(</span><span class="n">node_count</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_swarms</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">swarms_without_improvement</span> <span class="o">&gt;=</span> <span class="n">max_no_improvement</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="n">vertices</span><span class="p">,</span> <span class="n">cycle_lengths</span> <span class="o">=</span> <span class="n">swarm_traversal</span><span class="p">(</span><span class="n">pheromones</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
        <span class="n">pheromones</span> <span class="o">=</span> <span class="n">pheromone_evaporation</span><span class="p">(</span><span class="n">pheromones</span><span class="p">)</span>
        <span class="n">best_cycle_index</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">cycle_lengths</span><span class="p">)</span>
        <span class="n">best_cycle</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">best_cycle_index</span><span class="p">]</span>
        <span class="n">best_cycle_length</span> <span class="o">=</span> <span class="n">cycle_lengths</span><span class="p">[</span><span class="n">best_cycle_index</span><span class="p">]</span>
        <span class="n">pheromones</span> <span class="o">=</span> <span class="n">pheromone_release</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">best_cycle</span><span class="p">,</span> <span class="n">best_cycle_length</span><span class="p">,</span> <span class="n">pheromones</span><span class="p">)</span>
        <span class="n">pheromones</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">pheromones</span><span class="p">)</span>
        <span class="n">swarms_evaluated</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">cycle_lengths</span><span class="p">[</span><span class="n">best_cycle_index</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">graph</span><span class="p">.</span><span class="n">optimal_cycle_length</span><span class="p">:</span>
            <span class="n">graph</span><span class="p">.</span><span class="n">remove_vertices</span><span class="p">()</span>
            <span class="n">graph</span><span class="p">.</span><span class="n">add_vertices</span><span class="p">(</span><span class="n">best_cycle</span><span class="p">)</span>
            <span class="n">graph</span><span class="p">.</span><span class="n">optimal_cycle</span> <span class="o">=</span> <span class="n">ShortestPath</span><span class="p">(</span><span class="n">best_cycle_length</span><span class="p">,</span> <span class="n">best_cycle</span><span class="p">)</span>
            <span class="n">evaluations_until_solved</span> <span class="o">=</span> <span class="n">swarms_evaluated</span>
            <span class="n">swarms_without_improvement</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.0001</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">AlgorithmResult</span><span class="p">(</span><span class="n">swarms_evaluated</span><span class="p">,</span> <span class="n">evaluations_until_solved</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">swarms_without_improvement</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">yield</span> <span class="n">AlgorithmResult</span><span class="p">(</span><span class="n">swarms_evaluated</span><span class="p">,</span> <span class="n">evaluations_until_solved</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">initialize_pheromones</span><span class="p">(</span><span class="n">node_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="s">"""Initialize the pheromone array"""</span>
    <span class="n">pheromones</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">node_count</span><span class="p">,</span> <span class="n">node_count</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="p">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">pheromones</span><span class="p">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
            <span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">):</span>
        <span class="n">row_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">row_sum</span> <span class="o">/</span> <span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="n">row_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/=</span> <span class="n">row_sum</span>
    <span class="k">return</span> <span class="n">pheromones</span>


<span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">pheromones</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="s">"""Normalize the pheromone matrix into probabilities"""</span>
    <span class="n">node_count</span> <span class="o">=</span> <span class="n">pheromones</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">):</span>
        <span class="n">row_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/=</span> <span class="n">row_sum</span>
    <span class="k">return</span> <span class="n">pheromones</span>


<span class="k">def</span> <span class="nf">swarm_traversal</span><span class="p">(</span><span class="n">pheromones</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="s">"""Traverse the graph with a number of ants equal to the number of nodes"""</span>
    <span class="n">node_count</span> <span class="o">=</span> <span class="n">pheromones</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">swarm_size</span> <span class="o">=</span> <span class="n">node_count</span> <span class="o">*</span> <span class="n">node_count</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">node_count</span><span class="p">]</span> <span class="o">*</span> <span class="n">swarm_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">"i,i,i"</span><span class="p">)</span>
    <span class="n">cycle_lengths</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">swarm_size</span>
    <span class="c1"># Traverse the graph swarm_size times
</span>    <span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">swarm_size</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
        <span class="n">futures</span> <span class="o">=</span> <span class="p">[</span><span class="n">executor</span><span class="p">.</span><span class="n">submit</span><span class="p">(</span><span class="n">traverse</span><span class="p">,</span> <span class="n">node_count</span><span class="p">,</span> <span class="n">pheromones</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">swarm_size</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">completed</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">as_completed</span><span class="p">(</span><span class="n">futures</span><span class="p">)):</span>
            <span class="n">cycle_length</span><span class="p">,</span> <span class="n">cycle</span> <span class="o">=</span> <span class="n">completed</span><span class="p">.</span><span class="n">result</span><span class="p">()</span>
            <span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cycle</span>
            <span class="n">cycle_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cycle_length</span>
    <span class="k">return</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">cycle_lengths</span>


<span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">node_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">pheromones</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
             <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="s">"""Perform a traversal through the graph"""</span>
    <span class="c1"># Each traversal consists of node_count vertices
</span>    <span class="n">current_node</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">current_node</span><span class="p">])</span>
    <span class="n">cycle_length</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">node_count</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">"i,i,i"</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">row_sorted_indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">pheromones</span><span class="p">[</span><span class="n">current_node</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="n">pheromones</span><span class="p">[</span><span class="n">current_node</span><span class="p">,</span> <span class="p">:],</span> <span class="n">row_sorted_indices</span><span class="p">)</span>
        <span class="n">cumul</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">row</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">cumul</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">cumul</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">cumul</span>

        <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">chance</span> <span class="o">=</span> <span class="n">random</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)):</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="n">row_sorted_indices</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">chance</span> <span class="o">&lt;=</span> <span class="n">row</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">and</span> <span class="n">candidate</span> <span class="o">!=</span> <span class="n">current_node</span> <span class="ow">and</span> <span class="n">candidate</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">candidate</span>
                <span class="k">break</span>
        <span class="c1"># If no suitable index was found, the generated chance was probably too low
</span>        <span class="c1"># Pick the first index that's not itself and not visited yet
</span>        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">candidate</span> <span class="o">=</span> <span class="n">row_sorted_indices</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">candidate</span> <span class="o">!=</span> <span class="n">current_node</span> <span class="ow">and</span> <span class="n">candidate</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">candidate</span>
                    <span class="k">break</span>

        <span class="n">distance</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">current_node</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span>
        <span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_node</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">distance</span><span class="p">)</span>
        <span class="n">cycle_length</span> <span class="o">+=</span> <span class="n">distance</span>
        <span class="n">visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">current_node</span> <span class="o">=</span> <span class="n">index</span>
    <span class="c1"># Add the last vertex back to the starting node
</span>    <span class="n">distance</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">current_node</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">vertices</span><span class="p">[</span><span class="n">node_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_node</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">distance</span><span class="p">)</span>
    <span class="n">cycle_length</span> <span class="o">+=</span> <span class="n">distance</span>
    <span class="k">return</span> <span class="n">cycle_length</span><span class="p">,</span> <span class="n">vertices</span>


<span class="k">def</span> <span class="nf">pheromone_evaporation</span><span class="p">(</span><span class="n">pheromones</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="s">"""Evaporation of pheromones after each traversal"""</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">np</span><span class="p">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">pheromones</span><span class="p">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="n">pheromones</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">pheromones</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">pheromones</span>


<span class="k">def</span> <span class="nf">pheromone_release</span><span class="p">(</span><span class="n">vertices</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">best_cycle</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
                      <span class="n">best_cycle_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">pheromones</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="s">"""Perform pheromone release, with elitism towards shorter cycles"""</span>
    <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">cycle</span><span class="p">:</span>
            <span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">weight</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">best_cycle</span><span class="p">:</span>
        <span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">best_cycle_length</span>

    <span class="k">return</span> <span class="n">pheromones</span>
</code></pre></div></div>

<h3 id="concluding">Concluding</h3>
<p>Well, that’s about all I have to say about this topic so far. Since I always wanted to dabble into genetic algorithms and ant colony optimization, this was a nice little project to keep me occupied. I’m currently
investing pretty much all my spare time into learning Rust, so this is definitely the last Python project I’ll post for a while. I already use Python in my day-to-day work, and since I do heavily prefer statically-typed compiled languages, and I’m a sucker for performance, expect a lot of Rust in the future. I’m currently playing around with cloth simulation, wave function collapse and procedural generation, so expect several of those (and other) little adventures to appear here soon. I played around with a fractal zoomer for the Mandelbrot set using <a href="https://github.com/taichi-dev/taichi" target="_blank">Taichi</a> to get it to run on the GPU, but I’m thinking to<br />
<img src="http://localhost:4000/assets/tsp/rewriteinrust.jpg" alt="rewrite in rust" /><br />
and use <a href="https://bevyengine.org/" target="_blank">Bevy</a>, since that will probably enable me to zoom into fractals even further than what Python allows me to crunch out. We’ll see. If not, I’ll update this article with the github link to my project in Python. So much to do, so little time ;-)</p>

<p>In any case, thank you for reading this, I do hope it sparked some interest, and you learned something! I’m 100% only a rookie concerning genetic algorithms and ant colony optimization, but this project and the little bit of study I needed to crank it out at least familiarized me with the concepts involved. I hope this inspires at least some people to lay off the ChatGPT’s of the world, and learn new stuff the old school way, because it’s just a whole lot of fun ;-)</p>

  </section>
  <section id="disqus_thread"></section><!-- /#disqus_thread -->
</article>

    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'http://localhost:4000/2023/traveling-salesman/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2023/traveling-salesman'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
      };

      (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = '//peculiar-coding-endeavours.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
       })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>



      </div>

      <footer class="footer">
  <span class="footer__copyright">&copy; 2023 Tom van Schaijk. All rights reserved.</span>
</footer>

<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script type="text/javascript" src="/js/main.js?1682909671007910591"></script>


    </div>

<!-- load mathjax -->
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

  </body>
</html>