<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  

  <title>Traveling salesman problem</title>
  <meta name="description" content="The traveling salesman problem is one of those annoying interview questions you sometimes get hurled at you, accompanied by ‚ÄúHow would you solve this‚Äù? I remember a time when I was a fresh hatchling straight out of college, finding myself in that exact situation. I‚Äôll spare you the details, but I can tell you I didn‚Äôt get particularly far üòâ

">
  <meta name="author" content="Tom van Schaijk">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Traveling salesman problem">
  <meta name="twitter:description" content="The traveling salesman problem is one of those annoying interview questions you sometimes get hurled at you, accompanied by ‚ÄúHow would you solve this‚Äù? I remember a time when I was a fresh hatchling straight out of college, finding myself in that exact situation. I‚Äôll spare you the details, but I can tell you I didn‚Äôt get particularly far üòâ

">
  
  <meta name="twitter:image" content="/images/favicons/favicon-194x194.png" />

  <meta property="og:type" content="article">
  <meta property="og:title" content="Traveling salesman problem">
  <meta property="og:description" content="The traveling salesman problem is one of those annoying interview questions you sometimes get hurled at you, accompanied by ‚ÄúHow would you solve this‚Äù? I remember a time when I was a fresh hatchling straight out of college, finding myself in that exact situation. I‚Äôll spare you the details, but I can tell you I didn‚Äôt get particularly far üòâ

">
  <meta property="og:image" content="/images/favicons/favicon.png?" />

  <link rel="apple-touch-icon" sizes="57x57" href="/images/favicons/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/images/favicons/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/images/favicons/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/favicons/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/images/favicons/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/images/favicons/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/images/favicons/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/images/favicons/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-touch-icon-180x180.png">
  <!-- <link rel="icon" type="image/png" href="/images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-194x194.png" sizes="194x194">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="/images/favicons/android-chrome-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-16x16.png" sizes="16x16"> -->
  <link rel="manifest" href="/images/favicons/manifest.json">
  <link rel="shortcut icon" type="image/png" href="/images/favicons/favicon.png?">
  <meta name="msapplication-TileColor" content="#ffc40d">
  <meta name="msapplication-TileImage" content="/images/favicons/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">
  
  <link rel="stylesheet" href="/css/main.css?1737851978490887900">
  <link rel="canonical" href="http://localhost:4000/2023/traveling-salesman/">
  <link rel="alternate" type="application/rss+xml" title="Peculiar Coding Endeavours" href="/feed.xml">
</head>


  <body>
    <span class="mobile btn-mobile-menu">
  <i class="icon icon-list btn-mobile-menu__icon"></i>
  <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
</span>

<header class="panel-cover" style="background-image: url(/images/cover.jpg)">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">
        <a href="/" title="Peculiar Coding Endeavours Home">
          <img src="/images/profile.jpg" class="user-image" alt="My Profile Photo">
          <h1 class="panel-cover__title panel-title">Peculiar Coding Endeavours</h1>
        </a>
        <hr class="panel-cover__divider">
        <p class="panel-cover__description">Software engineer. Algorithm & data structures nut. On my way to learning AI. Eternal student.</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="Blog" class="blog-button">Blog</a></li>
            </ul>
          </nav>

          <nav class="cover-navigation navigation--social">
            <ul class="navigation">
            
              
              <!-- YouTube -->
              <li class="navigation__item">
                <a href="https://www.youtube.com/@peculiar-coding-endeavours" title="YouTube" target="_blank">
                  <i class="icon icon-social-youtube"></i>
                  <span class="label">YouTube</span>
                </a>
              </li>
            

            
            <!-- GitHub -->
            <li class="navigation__item">
              <a href="https://www.github.com/tomvanschaijk" title="GitHub" target="_blank">
                <i class="icon icon-social-github"></i>
                <span class="label">GitHub</span>
              </a>
            </li>
          

            
              <!-- LinkedIn -->
              <li class="navigation__item">
                <a href="https://www.linkedin.com/in/tom-van-schaijk" title="LinkedIn" target="_blank">
                  <i class="icon icon-social-linkedin"></i>
                  <span class="label">LinkedIn</span>
                </a>
              </li>
            

            
              <!-- Email -->
              <li class="navigation__item">
                <a href="mailto:vanschaijktom@hotmail.com" title="vanschaijktom@hotmail.com" target="_blank">
                  <i class="icon icon-mail"></i>
                  <span class="label">Email</span>
                </a>
              </li>
            

            <!-- RSS -->
            <li class="navigation__item">
              <a href="/feed.xml" title="Subscribe" target="_blank">
                <i class="icon icon-rss"></i>
                <span class="label">RSS</span>
              </a>
            </li>

            </ul>
          </nav>

        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>


    <div class="content-wrapper">
      <div class="content-wrapper__inner">
        <article class="post-container post-container--single">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="1 May 2023" class="post-meta__date date">1 May 2023</time>
      
      &#8226; <span class="post-meta__tags">on <a href="/tags/#tsp">tsp</a> <a href="/tags/#algorithms">algorithms</a> <a href="/tags/#python">python</a> </span>
      
    </div>
    <h1 class="post-title">Traveling salesman problem</h1>
  </header>

  <section class="post">
    <p>The traveling salesman problem is one of those annoying interview questions you sometimes get hurled at you, accompanied by ‚ÄúHow would you solve this‚Äù? I remember a time when I was a fresh hatchling straight out of college, finding myself in that exact situation. I‚Äôll spare you the details, but I can tell you I didn‚Äôt get particularly far üòâ</p>

<p>Times change, though, and over the years I grew into the type of software engineer that definitely prefers to work with data structures and algorithms over the next ‚Äúbest‚Äù framework used to make text and images appear in a web browser. If that happens to be your cup of tea, don‚Äôt get too offended; I‚Äôm an UI-ignorant back-end kind of guy, and you will undoubtedly run circles around me if it comes to any
front-end related tech.</p>

<p><img src="http://localhost:4000/assets/tsp/salesmen.jpg" alt="salesmen" /></p>

<h3 id="some-solutions">Some solutions‚Ä¶</h3>

<p>Now, quite a few years later, I thought it‚Äôd be a nice moment to provide a few potential solutions, and give you a little bit of a summary regarding how to go about it. I assume you know what the <a href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" target="_blank">Traveling Salesman Problem</a> entails, at least from a high level. In short, the goal is to find the Hamiltonian cycle in an undirected weighted graph with the lowest cost. It‚Äôs one of those nice annoying NP-hard problems, so more than enough ways to have fun with it. It has many applications, from planning, logistics to manufacturing microchips. In this article, I‚Äôll go over 4 example implementations of possible solutions to the problem:</p>
<ul>
  <li>a simple brute force algorithm, guaranteed to give you the optimal shortest distance, but obviously horribly slow</li>
  <li>another guaranteed optimal solution, but quite a bit more efficient, using dynamic programming</li>
  <li>an approximation of a solution using genetic algorithms</li>
  <li>another approximation, using ant colony optimization</li>
</ul>

<p>I‚Äôve been interested in genetic algorithms and ant colony optimization for a while now, and the traveling salesman problem is a nice use-case to apply these algorithms to. In case you are not familiar with one or both of them, you can find more information about <a href="https://en.wikipedia.org/wiki/Genetic_algorithm">Genetic algorithms</a> and <a href="https://en.wikipedia.org/wiki/Ant_colony_optimization_algorithms">Ant Colony Optimization</a> all over the internet. Or you can ask ChatGPT, apparently that‚Äôs quite the trend lately. There are several other ways to go about finding solutions, like simulated annealing, n-opt and several of its variations, but I wanted to stick to what triggered my curiosity the most.</p>

<h3 id="the-project">The project</h3>
<p>The full code of the project is available on my <a href="https://github.com/tomvanschaijk/travelingsalesman" target="_blank">GitHub</a>. The requirements to run it are pretty basic. It‚Äôs all Python code, and I mainly use PyGame, Numpy, Asyncio and Aiostream. Just install the requirements in requirements.txt and you‚Äôll be set. You can preview the end result right here:</p>
<div class="embed-container">
    <iframe width="640" height="390" src="https://www.youtube.com/embed/XCZSwM--vCA" frameborder="0" allowfullscreen=""></iframe>
</div>
<style>
.embed-container {
  position: relative;
  padding-bottom: 56.25%;
  height: 0;
  overflow: hidden;
  max-width: 100%;
}
.embed-container iframe,
.embed-container object,
.embed-container embed {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
</style>

<p>In fact, give that a quick gander, keep it open in your browser to get back to every now and then, and the rest of the article will quickly become clear. Obviously, cloning it yourself and running it will help your understanding even more.</p>

<p>The PyGame window that pops up when running shows you 5 panes. The top center one is the one where you can left-click to add points. These points will be the destinations our supposed salesman will have to visit. The first point you create will be green, and will be the starting point and end destination. All other blue ones are the cities to be visited before getting back to the starting point. Hitting the spacebar will reset the screen, enter starts the algorithm. The distances between points are simply the Euclidean distance in pixels between the points.</p>

<p>Since brute force and dynamic programming solutions are inherently slow for anything more than a few points, you‚Äôll notice there‚Äôs a cut-off point where those algorithms are not being taken along for the ride anymore. It would simply take too much time, as the time complexity for both just explodes when the amount of points gets too high. Dynamic programming will be used for a bit longer than brute force, but when you start getting in the double digits in terms of destination count, both will not be executed anymore.</p>

<p>In case you do follow along in the code and check out the GitHub project, there aren‚Äôt a lot of files of interest:</p>
<ul>
  <li>main.py: nothing you wouldn‚Äôt expect. The only code of slight interest there is how to run the 4 algorithms concurrently. All the rest is setup for PyGame, running the main ‚Äúgame loop‚Äù</li>
  <li>graph.py: contains an implementation of an undirected weighted graph, slightly tailored to the current problem at hand</li>
  <li>the folder /solvers contains the implementations of the 4 algorithms. The rest of the article will mostly focus on those</li>
</ul>

<h3 id="processing-the-results">Processing the results</h3>
<p>As stated earlier, the main.py file doesn‚Äôt contain much regarding the actual problem. However, maybe one little thing to touch on is how the 4 algorithms are executed concurrently, and results are processed as they come in.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">algorithms</span> <span class="o">=</span> <span class="p">[</span><span class="n">algorithm</span> <span class="k">for</span> <span class="n">algorithm</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">__algorithms</span>
              <span class="k">if</span> <span class="n">algorithm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">]</span>
<span class="n">zipped</span> <span class="o">=</span> <span class="n">stream</span><span class="p">.</span><span class="n">ziplatest</span><span class="p">(</span><span class="o">*</span><span class="n">algorithms</span><span class="p">)</span>
<span class="n">merged</span> <span class="o">=</span> <span class="n">stream</span><span class="p">.</span><span class="nb">map</span><span class="p">(</span><span class="n">zipped</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="k">async</span> <span class="k">with</span> <span class="n">merged</span><span class="p">.</span><span class="n">stream</span><span class="p">()</span> <span class="k">as</span> <span class="n">streamer</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">for</span> <span class="n">resultset</span> <span class="ow">in</span> <span class="n">streamer</span><span class="p">:</span>

</code></pre></div></div>

<p>To explain what goes on there, we‚Äôll consider the following simple example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">aiostream</span> <span class="kn">import</span> <span class="n">stream</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">process_results_interleaved</span><span class="p">(</span><span class="n">races</span><span class="p">):</span>
    <span class="n">combine</span> <span class="o">=</span> <span class="n">stream</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="o">*</span><span class="n">races</span><span class="p">)</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">combine</span><span class="p">.</span><span class="n">stream</span><span class="p">()</span> <span class="k">as</span> <span class="n">streamer</span><span class="p">:</span>
        <span class="k">async</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">streamer</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">process_results_packet</span><span class="p">(</span><span class="n">races</span><span class="p">):</span>
    <span class="n">zipped</span> <span class="o">=</span> <span class="n">stream</span><span class="p">.</span><span class="n">ziplatest</span><span class="p">(</span><span class="o">*</span><span class="n">races</span><span class="p">)</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="n">stream</span><span class="p">.</span><span class="nb">map</span><span class="p">(</span><span class="n">zipped</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">merged</span><span class="p">.</span><span class="n">stream</span><span class="p">()</span> <span class="k">as</span> <span class="n">streamer</span><span class="p">:</span>
        <span class="k">async</span> <span class="k">for</span> <span class="n">resultset</span> <span class="ow">in</span> <span class="n">streamer</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">resultset</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">race</span><span class="p">(</span><span class="n">racer</span><span class="p">,</span> <span class="n">sleep_time</span><span class="p">,</span> <span class="n">checkpoints</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">checkpoints</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">sleep_time</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">checkpoints</span><span class="p">:</span>
            <span class="k">yield</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">racer</span><span class="si">}</span><span class="s"> finished!"</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">racer</span><span class="si">}</span><span class="s"> hits checkpoint: </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s">"</span>


<span class="k">def</span> <span class="nf">create_races</span><span class="p">(</span><span class="n">checkpoints</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">race</span><span class="p">(</span><span class="s">"Turtle"</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">checkpoints</span><span class="p">),</span>
            <span class="n">race</span><span class="p">(</span><span class="s">"Hare"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">checkpoints</span><span class="p">),</span>
            <span class="n">race</span><span class="p">(</span><span class="s">"Dragster"</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">checkpoints</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">checkpoints</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"Starting race, processing results as they come in from each contestant:"</span><span class="p">)</span>
    <span class="n">races</span> <span class="o">=</span> <span class="n">create_races</span><span class="p">(</span><span class="n">checkpoints</span><span class="p">)</span>
    <span class="n">asyncio</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">process_results_interleaved</span><span class="p">(</span><span class="n">races</span><span class="p">))</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"Starting race, processing results in packets:"</span><span class="p">)</span>
    <span class="n">races</span> <span class="o">=</span> <span class="n">create_races</span><span class="p">(</span><span class="n">checkpoints</span><span class="p">)</span>
    <span class="n">asyncio</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">process_results_packet</span><span class="p">(</span><span class="n">races</span><span class="p">))</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div></div>

<p>Just go over the code real quick, and it‚Äôll become pretty clear what the setup is. We‚Äôll have a race between a turtle, a hare and a fancy dragster car. They go through a number of checkpoints, and moving from one to the next simply takes them some amount of time, clumsily simulated by sleeping for an amount of time in the loop where they go through the checkpoints. The turtle takes 2 seconds to go from a checkpoint to the next, the hare takes 1 second, and the racing car only takes 300ms. Easy.</p>

<p>The whole reason behind this little fantasy is to show you how to process the results of this contest as each contestant hits a checkpoint. I first show an update every time a racer hits a checkpoint, in process_results_interleaved. Then, in process_results_packet, you‚Äôll see that you get the full set of results whenever any of the racers hits a checkpoint. The output looks like this:</p>

<p><img src="http://localhost:4000/assets/tsp/race_results.png" alt="race_results" /></p>

<p>The whole point of this is that I wanted a way to combine the results of several concurrently running asynchronous generators as they come in, and, more importantly: identify exactly which result comes from which generator, without necessarily putting code in each specific generator to help with that identification. I wanted to keep the implementation of each algorithm focused on what it‚Äôs supposed to do and not tailor it to the fact that I want to use it in a scenario where I want to run several at the same time and compare them. That‚Äôs not a concern the algorithm needs to care for.</p>

<p>When you go and run the 4 different algorithms that will look for a solution to the TSP, you want to receive updates whenever some improvement is reached, or whenever something useful can be put on the screen, without polluting the generators with some identifying code to update the right result set. So the way it‚Äôs done in process_results_packet will be the method to use for running the 4 TSP algorithms together. I‚Äôll just put the 4 algorithms in an array, start them all at the same time, and every time any one of them yields a result, I get a dictionary back with the updated results. It‚Äôs these few lines that do the trick:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">zipped</span> <span class="o">=</span> <span class="n">stream</span><span class="p">.</span><span class="n">ziplatest</span><span class="p">(</span><span class="o">*</span><span class="n">races</span><span class="p">)</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="n">stream</span><span class="p">.</span><span class="nb">map</span><span class="p">(</span><span class="n">zipped</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">merged</span><span class="p">.</span><span class="n">stream</span><span class="p">()</span> <span class="k">as</span> <span class="n">streamer</span><span class="p">:</span>
        <span class="p">...</span>
</code></pre></div></div>

<p>Quite simple and quite powerful. Ok, let‚Äôs get to the interesting parts now!</p>

<h3 id="a-brute-force-approach">A brute force approach</h3>
<p>Whenever you start implementing a non-trivial algorithm, it‚Äôs always a good idea to start with an implementation that is focused on getting the correct result, disregarding any tendency you might have to go for early optimizations. Make it as simple and clear as you can, but focus on achieving a 100% correct solution. Explore the full set of possible solutions, perform an exhaustive search and simply keep updating the candidate solution every time there‚Äôs an improvement until there are no more candidate solutions, and you just found yourself the optimal solution. It will help you understand the problem, and you can use this initial iteration as a reference to compare future solutions to, and doublecheck them for correctness.</p>

<p>In case of the TSP, implementing a brute-force solution is quite easy. We simply generate all possible permutations of the set of destinations, evaluate the full path distance from start through all nodes back to the initial node, and store the optimal path length and the sequence of nodes traveled in order to achieve it. Contrary to what I just said a sentence or two ago, I‚Äôd say some small optimizations are permitted. One such obvious thing is that a sequence of A - B - C - A is identical in length to the sequence A - C - B - A, and as such, both do not need to be evaluated. We only consider unique permutations. We obviously don‚Äôt need to continuously build the actual graph under consideration for the algorithm to work. However, I wanted to display the paths under evaluation as the algorithm does its work, so that little bit of extra effort is worth it for this project.</p>

<p>If you check the <a href="https://youtu.be/XCZSwM--vCA" target="_blank">clip</a> I linked before, you will see that during each iteration, a new path permutation (the lines in white) is being evaluated. Whenever a path is shorter than the known shortest path, that path is updated and shown in green. If you want to follow along with a bit more detail, just change the sleeping time at the end of the for-loop to something that gives you a bit more time to realize what‚Äôs occurring.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">def</span> <span class="nf">brute_force</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="n">AlgorithmResult</span><span class="p">]:</span>
    <span class="s">"""Solve the TSP problem with a brute force implementation, running through all permutations"""</span>
    <span class="n">unique_permutations</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">paths_evaluated</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">evaluations_until_solved</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">key</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">sub_keys</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">for</span> <span class="n">permutation</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">(</span><span class="n">sub_keys</span><span class="p">):</span>
        <span class="n">permutation</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span><span class="p">,)</span> <span class="o">+</span> <span class="n">permutation</span> <span class="o">+</span> <span class="p">(</span><span class="n">start</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">permutation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unique_permutations</span> <span class="ow">and</span> <span class="n">permutation</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unique_permutations</span><span class="p">:</span>
            <span class="n">paths_evaluated</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">unique_permutations</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span>
            <span class="n">current_path_length</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">start</span>
            <span class="n">vertices</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">permutation</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">distance</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">)]</span>
                <span class="n">current_path_length</span> <span class="o">+=</span> <span class="n">distance</span>
                <span class="n">vertices</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">distance</span><span class="p">))</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">key</span>

            <span class="n">graph</span><span class="p">.</span><span class="n">remove_vertices</span><span class="p">()</span>
            <span class="n">graph</span><span class="p">.</span><span class="n">add_vertices</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">current_path_length</span> <span class="o">&lt;</span> <span class="n">graph</span><span class="p">.</span><span class="n">optimal_cycle_length</span><span class="p">:</span>
                <span class="n">graph</span><span class="p">.</span><span class="n">optimal_cycle</span> <span class="o">=</span> <span class="n">ShortestPath</span><span class="p">(</span><span class="n">current_path_length</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>
                <span class="n">evaluations_until_solved</span> <span class="o">=</span> <span class="n">paths_evaluated</span>
            <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.0001</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">AlgorithmResult</span><span class="p">(</span><span class="n">paths_evaluated</span><span class="p">,</span> <span class="n">evaluations_until_solved</span><span class="p">)</span>

    <span class="n">graph</span><span class="p">.</span><span class="n">remove_vertices</span><span class="p">()</span>
    <span class="n">graph</span><span class="p">.</span><span class="n">add_vertices</span><span class="p">(</span><span class="n">graph</span><span class="p">.</span><span class="n">optimal_cycle</span><span class="p">.</span><span class="n">vertices</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">AlgorithmResult</span><span class="p">(</span><span class="n">paths_evaluated</span><span class="p">,</span> <span class="n">evaluations_until_solved</span><span class="p">)</span>
</code></pre></div></div>

<p>And there you have it. Problem solved! Well, kind of. For an ideal path between, let‚Äôs say, 5 or so points, I guess this brute force approach is still ok. You‚Äôll notice, though, that when you have 8 or more points, things become very painful. Since we check all permutations, the runtime of the brute force algorithm is N! since we want to consider every possible vertex between each pair of nodes. Quite horrific, but at least we now have a way to test other, more optimal solutions for correctness.</p>

<h3 id="dynamic-programming-to-the-rescue">Dynamic programming to the rescue</h3>

<p>That brings us to an approach we‚Äôve all used as a first optimization for so many algorithmic problems: dynamic programming. That will bring the time complexity down from O(n!) to O(n¬≤2n). For the more curious readers that couldn‚Äôt help but scroll down instead of reading this, you‚Äôve noticed that this requires quite a bit more code than our naive brute force approach. This already hammers home the statement about not diving into optimization too early. It‚Äôs easy to make a small mistake, and depending on how involved a solution you start to implement beyond brute force tactics, it can be quite cumbersome to debug.</p>

<p>The specific implementation I went for is one such example. As often the case when using dynamic programming, memoization is a big help here. But not only that, you also notice some bit-wise operations going on to further improve the speed of this solution. I will explain the steps we go through in this approach as best I can.</p>

<p>The overall approach here is that we will no longer consider all possible full paths through the set of nodes until we find the shortest one. As we do in dynamic programming, we solve a subset of the problem and keep expanding on it until we find a solution to the full problem. During this expansion, we use previously achieved results to avoid doing double work, using memoization. Here‚Äôs the full code (for all you copy-paste problem solvers out there üòâ), read through it, and then I‚Äôll focus on some specific parts. Just in case dynamic programming is a new concept to you, check out some articles or video tutorials online, maybe comparing greedy algorithms to dynamic programming for problems like the knapsack problem or coin change problem. That should help you get it down. The full code:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">def</span> <span class="nf">dynamic_programming</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span>
                              <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="n">AlgorithmResult</span><span class="p">]:</span>
    <span class="s">"""Solve the TSP problem with dynamic programming"""</span>
    <span class="n">node_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">key</span>
    <span class="n">memo</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">node_count</span><span class="p">)]</span> <span class="k">for</span> <span class="n">__</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">)]</span>
    <span class="n">optimal_cycle</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">optimal_cycle_length</span> <span class="o">=</span> <span class="n">maxsize</span>
    <span class="n">cycles_evaluated</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">evaluations_until_solved</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">memo</span> <span class="o">=</span> <span class="n">setup</span><span class="p">(</span><span class="n">memo</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">nodes_in_subcycle</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">node_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">subcycle</span> <span class="ow">in</span> <span class="n">initialize_combinations</span><span class="p">(</span><span class="n">nodes_in_subcycle</span><span class="p">,</span> <span class="n">node_count</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_not_in</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">subcycle</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">cycles_evaluated</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Look for the best next node to attach to the cycle
</span>            <span class="k">for</span> <span class="n">next_node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">next_node</span> <span class="o">==</span> <span class="n">start</span> <span class="ow">or</span> <span class="n">is_not_in</span><span class="p">(</span><span class="n">next_node</span><span class="p">,</span> <span class="n">subcycle</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="n">subcycle_without_next_node</span> <span class="o">=</span> <span class="n">subcycle</span> <span class="o">^</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">next_node</span><span class="p">)</span>
                <span class="n">min_cycle_length</span> <span class="o">=</span> <span class="n">maxsize</span>
                <span class="k">for</span> <span class="n">last_node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">last_node</span> <span class="o">==</span> <span class="n">start</span> <span class="ow">or</span> <span class="n">last_node</span> <span class="o">==</span> <span class="n">next_node</span> <span class="ow">or</span> <span class="n">is_not_in</span><span class="p">(</span><span class="n">last_node</span><span class="p">,</span> <span class="n">subcycle</span><span class="p">)):</span>
                        <span class="k">continue</span>

                    <span class="n">new_cycle_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">memo</span><span class="p">[</span><span class="n">last_node</span><span class="p">][</span><span class="n">subcycle_without_next_node</span><span class="p">]</span> <span class="o">+</span> <span class="n">distances</span><span class="p">[(</span><span class="n">last_node</span><span class="p">,</span> <span class="n">next_node</span><span class="p">)])</span>
                    <span class="k">if</span> <span class="n">new_cycle_length</span> <span class="o">&lt;</span> <span class="n">min_cycle_length</span><span class="p">:</span>
                        <span class="n">min_cycle_length</span> <span class="o">=</span> <span class="n">new_cycle_length</span>
                    <span class="n">memo</span><span class="p">[</span><span class="n">next_node</span><span class="p">][</span><span class="n">subcycle</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_cycle_length</span>

        <span class="n">evaluations_until_solved</span> <span class="o">=</span> <span class="n">cycles_evaluated</span>
        <span class="n">optimal_cycle_length</span> <span class="o">=</span> <span class="n">calculate_optimal_cycle_length</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">nodes_in_subcycle</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
        <span class="n">optimal_cycle</span> <span class="o">=</span> <span class="n">find_optimal_cycle</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">nodes_in_subcycle</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">create_vertices</span><span class="p">(</span><span class="n">optimal_cycle</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
        <span class="n">graph</span><span class="p">.</span><span class="n">optimal_cycle</span> <span class="o">=</span> <span class="n">ShortestPath</span><span class="p">(</span><span class="n">optimal_cycle_length</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.0001</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">AlgorithmResult</span><span class="p">(</span><span class="n">cycles_evaluated</span><span class="p">,</span> <span class="n">evaluations_until_solved</span><span class="p">)</span>

    <span class="n">optimal_cycle_length</span> <span class="o">=</span> <span class="n">calculate_optimal_cycle_length</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">node_count</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
    <span class="n">optimal_cycle</span> <span class="o">=</span> <span class="n">find_optimal_cycle</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">node_count</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">create_vertices</span><span class="p">(</span><span class="n">optimal_cycle</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
    <span class="n">graph</span><span class="p">.</span><span class="n">remove_vertices</span><span class="p">()</span>
    <span class="n">graph</span><span class="p">.</span><span class="n">add_vertices</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
    <span class="n">graph</span><span class="p">.</span><span class="n">optimal_cycle</span> <span class="o">=</span> <span class="n">ShortestPath</span><span class="p">(</span><span class="n">optimal_cycle_length</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">AlgorithmResult</span><span class="p">(</span><span class="n">cycles_evaluated</span><span class="p">,</span> <span class="n">evaluations_until_solved</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="n">memo</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="s">"""Prepare the array used for memoization during the dynamic programming algorithm"""</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">node</span><span class="p">.</span><span class="n">key</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">memo</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">start</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[(</span><span class="n">start</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">memo</span>


<span class="k">def</span> <span class="nf">initialize_combinations</span><span class="p">(</span><span class="n">nodes_in_subcycle</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">node_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="s">"""Initialize the combinations to consider in the next step of the algorithm"""</span>
    <span class="n">subcycle_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">initialize_combination</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nodes_in_subcycle</span><span class="p">,</span> <span class="n">node_count</span><span class="p">,</span> <span class="n">subcycle_list</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">subcycle_list</span>


<span class="k">def</span> <span class="nf">initialize_combination</span><span class="p">(</span><span class="n">subcycle</span><span class="p">,</span> <span class="n">at</span><span class="p">,</span> <span class="n">nodes_in_subcycle</span><span class="p">,</span> <span class="n">node_count</span><span class="p">,</span> <span class="n">subcycle_list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="s">"""Initialize the combination to consider in the next step of the algorithm"""</span>
    <span class="n">elements_left_to_pick</span> <span class="o">=</span> <span class="n">node_count</span> <span class="o">-</span> <span class="n">at</span>
    <span class="k">if</span> <span class="n">elements_left_to_pick</span> <span class="o">&lt;</span> <span class="n">nodes_in_subcycle</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="n">nodes_in_subcycle</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">subcycle_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">subcycle</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="n">node_count</span><span class="p">):</span>
            <span class="n">subcycle</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span>
            <span class="n">initialize_combination</span><span class="p">(</span><span class="n">subcycle</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nodes_in_subcycle</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                   <span class="n">node_count</span><span class="p">,</span> <span class="n">subcycle_list</span><span class="p">)</span>
            <span class="n">subcycle</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_not_in</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">subcycle</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="s">"""Checks if the bit at the given index is a 0"""</span>
    <span class="k">return</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">subcycle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">calculate_optimal_cycle_length</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">node_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">memo</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                                   <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="s">"""Calculate the optimal cycle length"""</span>
    <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">node_count</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">optimal_cycle_length</span> <span class="o">=</span> <span class="n">maxsize</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">start</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">cycle_cost</span> <span class="o">=</span> <span class="n">memo</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">end</span><span class="p">]</span> <span class="o">+</span> <span class="n">distances</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">start</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">cycle_cost</span> <span class="o">&lt;</span> <span class="n">optimal_cycle_length</span><span class="p">:</span>
            <span class="n">optimal_cycle_length</span> <span class="o">=</span> <span class="n">cycle_cost</span>

    <span class="k">return</span> <span class="n">optimal_cycle_length</span>


<span class="k">def</span> <span class="nf">find_optimal_cycle</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">node_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">memo</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                       <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]):</span>
    <span class="s">"""Recreate the optimal cycle"""</span>
    <span class="n">last_index</span> <span class="o">=</span> <span class="n">start</span>
    <span class="n">state</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">node_count</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">optimal_cycle</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">start</span> <span class="ow">or</span> <span class="n">is_not_in</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">j</span>
            <span class="n">prev_cycle_length</span> <span class="o">=</span> <span class="n">memo</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">state</span><span class="p">]</span> <span class="o">+</span> <span class="n">distances</span><span class="p">[(</span><span class="n">index</span><span class="p">,</span> <span class="n">last_index</span><span class="p">)]</span>
            <span class="n">new_cycle_length</span> <span class="o">=</span> <span class="n">memo</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">state</span><span class="p">]</span> <span class="o">+</span> <span class="n">distances</span><span class="p">[(</span><span class="n">j</span><span class="p">,</span> <span class="n">last_index</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">new_cycle_length</span> <span class="o">&lt;</span> <span class="n">prev_cycle_length</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">j</span>

        <span class="n">optimal_cycle</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">state</span> <span class="o">^</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">)</span>
        <span class="n">last_index</span> <span class="o">=</span> <span class="n">index</span>
    <span class="n">optimal_cycle</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="n">optimal_cycle</span><span class="p">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="n">optimal_cycle</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">optimal_cycle</span>


<span class="k">def</span> <span class="nf">create_vertices</span><span class="p">(</span><span class="n">optimal_cycle</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span>
                    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
    <span class="s">"""Transform the list of visited node keys to something our graph can work with"""</span>
    <span class="n">vertices</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">optimal_cycle</span><span class="p">)):</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[(</span><span class="n">optimal_cycle</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">optimal_cycle</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
        <span class="n">vertices</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">optimal_cycle</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">optimal_cycle</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">weight</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">vertices</span>
</code></pre></div></div>

<p>Again, in case you want to understand the steps at a high level, change the sleep time to about a second or so, and you will see what happens. Starting with a cycle of 2 nodes, building up to a cycle including all the points, we find the shortest possible path using the points we include in the cycle. Whenever an optimal solution is found for 2 points, we find an optimal solution for those 2 points plus 1 more, reusing what we have already learned so far. We keep doing that until the full set of nodes has been traveled. It‚Äôs really quite beautiful to see in action, in my opinion. How to achieve it, though?</p>

<h4 id="getting-the-memoization-matrix-set-up">Getting the memoization matrix set up</h4>

<p>We start out by preparing our memoization matrix:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">memo</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">node_count</span><span class="p">)]</span> <span class="k">for</span> <span class="n">__</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">)]</span>
<span class="p">...</span>
<span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="n">memo</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">node</span><span class="p">.</span><span class="n">key</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">memo</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">start</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[(</span><span class="n">start</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">memo</span>
</code></pre></div></div>

<p>Here, I create a matrix with a number of rows equal to the number of nodes we have and columns equal to 2 raised to the power of the number of nodes. So for 5 nodes, that‚Äôs a 5x32 matrix. As you may know, raising 2 to the power of N equals shifting a 1-bit to the left N times, since a move to the left doubles the binary value. It‚Äôs just faster using bit shifting, simple as that. We loop through each node, skipping the start node, and we store the optimal distance from the start node to each other node.</p>

<h4 id="other-helper-functions">Other helper functions</h4>

<p>Besides the preparation of the memoization matrix, other functions such as find_optimal_cycle and create_vertices are actually not terribly complicated or interesting. If we keep in mind that, during dynamic programming, we build on top of earlier achieved results (optimal paths through n nodes) to get the optimal result for n+1 nodes, it‚Äôs not hard to imagine we will need to consider a new set of cycles and nodes to evaluate whether adding a certain node to our cycle yields a more optimal results than adding another. Beyond that, in the visualization of the brute force algorithm ,you noticed we kept on drawing the vertices under consideration. For the dynamic programming solution, we simply want to build the new optimal cycle and put it on the screen, so we have some functions for that. Stepping through them with a small number of nodes will make it very clear what they do. Be sure to brush off those bit manipulator operations first üòâ</p>

<h4 id="just-one-more-thing">Just one more thing</h4>
<p>Maybe a bit of explanation on the initialize_combinations and initialize_combination methods: initialize_combinations will fill the subcycle_list variable using the initialize_combination method, that much is obvious. initialize_combination is a recursive method to generate bit sets, starting from an empty set (0). From an empty set, we want to set nodes_in_subcycle out of node_count bits to be 1 for all possible combinations. We keep track of which index position we‚Äôre at (indicated by variable i), try to set it to 1 and keep moving forward. At the end of that, we should have exactly node_count bits. If we don‚Äôt, we backtrack and flip off (not like that) the i-th bit and move to the next position. This is a classic backtracking problem, and if you want to learn more about it, look for backtracking tutorials for power sets.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize_combinations</span><span class="p">(</span><span class="n">nodes_in_subcycle</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">node_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="s">"""Initialize the combinations to consider in the next step of the algorithm"""</span>
    <span class="n">subcycle_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">initialize_combination</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nodes_in_subcycle</span><span class="p">,</span> <span class="n">node_count</span><span class="p">,</span> <span class="n">subcycle_list</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">subcycle_list</span>


<span class="k">def</span> <span class="nf">initialize_combination</span><span class="p">(</span><span class="n">subcycle</span><span class="p">,</span> <span class="n">at</span><span class="p">,</span> <span class="n">nodes_in_subcycle</span><span class="p">,</span> <span class="n">node_count</span><span class="p">,</span> <span class="n">subcycle_list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="s">"""Initialize the combination to consider in the next step of the algorithm"""</span>
    <span class="n">elements_left_to_pick</span> <span class="o">=</span> <span class="n">node_count</span> <span class="o">-</span> <span class="n">at</span>
    <span class="k">if</span> <span class="n">elements_left_to_pick</span> <span class="o">&lt;</span> <span class="n">nodes_in_subcycle</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="n">nodes_in_subcycle</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">subcycle_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">subcycle</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="n">node_count</span><span class="p">):</span>
            <span class="n">subcycle</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span>
            <span class="n">initialize_combination</span><span class="p">(</span><span class="n">subcycle</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nodes_in_subcycle</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                   <span class="n">node_count</span><span class="p">,</span> <span class="n">subcycle_list</span><span class="p">)</span>
            <span class="n">subcycle</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="solving-the-puzzle">Solving the puzzle</h4>

<p>This is where the actual work happens, and there‚Äôs a bit to it. Make sure the other functions are clear to you and the use of a memoization matrix in dynamic programming in general is a concept you understand.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span> <span class="n">nodes_in_subcycle</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">node_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">subcycle</span> <span class="ow">in</span> <span class="n">initialize_combinations</span><span class="p">(</span><span class="n">nodes_in_subcycle</span><span class="p">,</span> <span class="n">node_count</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_not_in</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">subcycle</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">cycles_evaluated</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Look for the best next node to attach to the cycle
</span>            <span class="k">for</span> <span class="n">next_node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">next_node</span> <span class="o">==</span> <span class="n">start</span> <span class="ow">or</span> <span class="n">is_not_in</span><span class="p">(</span><span class="n">next_node</span><span class="p">,</span> <span class="n">subcycle</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="n">subcycle_without_next_node</span> <span class="o">=</span> <span class="n">subcycle</span> <span class="o">^</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">next_node</span><span class="p">)</span>
                <span class="n">min_cycle_length</span> <span class="o">=</span> <span class="n">maxsize</span>
                <span class="k">for</span> <span class="n">last_node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">last_node</span> <span class="o">==</span> <span class="n">start</span> <span class="ow">or</span> <span class="n">last_node</span> <span class="o">==</span> <span class="n">next_node</span> <span class="ow">or</span> <span class="n">is_not_in</span><span class="p">(</span><span class="n">last_node</span><span class="p">,</span> <span class="n">subcycle</span><span class="p">)):</span>
                        <span class="k">continue</span>

                    <span class="n">new_cycle_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">memo</span><span class="p">[</span><span class="n">last_node</span><span class="p">][</span><span class="n">subcycle_without_next_node</span><span class="p">]</span> <span class="o">+</span> <span class="n">distances</span><span class="p">[(</span><span class="n">last_node</span><span class="p">,</span> <span class="n">next_node</span><span class="p">)])</span>
                    <span class="k">if</span> <span class="n">new_cycle_length</span> <span class="o">&lt;</span> <span class="n">min_cycle_length</span><span class="p">:</span>
                        <span class="n">min_cycle_length</span> <span class="o">=</span> <span class="n">new_cycle_length</span>
                    <span class="n">memo</span><span class="p">[</span><span class="n">next_node</span><span class="p">][</span><span class="n">subcycle</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_cycle_length</span>

        <span class="n">evaluations_until_solved</span> <span class="o">=</span> <span class="n">cycles_evaluated</span>
        <span class="n">optimal_cycle_length</span> <span class="o">=</span> <span class="n">calculate_optimal_cycle_length</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">nodes_in_subcycle</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
        <span class="n">optimal_cycle</span> <span class="o">=</span> <span class="n">find_optimal_cycle</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">nodes_in_subcycle</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">create_vertices</span><span class="p">(</span><span class="n">optimal_cycle</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
        <span class="n">graph</span><span class="p">.</span><span class="n">optimal_cycle</span> <span class="o">=</span> <span class="n">ShortestPath</span><span class="p">(</span><span class="n">optimal_cycle_length</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.0001</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">AlgorithmResult</span><span class="p">(</span><span class="n">cycles_evaluated</span><span class="p">,</span> <span class="n">evaluations_until_solved</span><span class="p">)</span>
</code></pre></div></div>

<p>As you can see, the outer loop increases the length of the cycle by 1 with each iteration. In every iteration, we find the optimal cycle of a certain length, increasing the cycle length until we have an optimal cycle equal to the number of nodes. The first inner loop goes over all the distinct subcycles we want to consider. Obviously, we only want to consider subcycles where the start node is actually part of the subcycle. Otherwise, that subcycle could not have started at the starting node. The function to check that is called is_not_in (I know it‚Äôs a one-line function‚Ä¶ in my defense, there‚Äôs a npm package called ‚Äúis_even‚Äù. So hold your horses üòÄ):</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">is_not_in</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">subcycle</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="s">"""Checks if the bit at the given index is a 0"""</span>
    <span class="k">return</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">subcycle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
</code></pre></div></div>

<p>and all that‚Äôs done here is check whether or not the bit at the index position in the subcycle is a 0. If it is, the node is not part of the subcycle.</p>

<p>After that, we loop over all the potential next nodes. Here, we only want to consider nodes that are actually in the subcycle and are not equal to our starting node. We then represent the next subcycle without this next node. We do this so we can use our memoization matrix to look up what the best partial tour length was without the next node already included. The last inner loop, where we cycle the last_node variable over the range of possible nodes, is there to test all possible end nodes of the currently considered subcycle, and consider which node best optimizes that subcycle. This last node can, of course, not be the start node or the next node that is fixed in the loop before and should be part of the current subcycle.</p>

<p>Per potential new last node, we check if the cost of the cycle with this last node is better than the currently known lowest cost (or shortest distance in our case). If so, we set the new min_cycle_length and store the best subcycle in the memoization matrix.</p>

<p>At the end of each new subcycle length, we do some bookkeeping and a little bit of work to reconstruct the actual newly found shortest cycle of length nodes_in_subcycle and yield that back so it can be displayed on screen. The functions calculate_optimal_cycle_length and find_optimal_cycle are responsible for this. If you are familiar with dynamic programming, reconstructing a solution from a memoization table will be familiar to you. The only bit of added complexity here is that this reconstruction is done using our bitmasks in the memoization table.</p>

<p>And that does it. If this is not entirely clear, I recommend you make sure the basics of dynamic programming and bit-wise operators are under your belt, and simply step through the code using a graph with 5 or so nodes. That allows you to still reason about the whole concept and actually follow along what is happening.</p>

<h4 id="beware-python-looping">Beware Python looping</h4>

<p>A final word of warning if you play around with this yourself: there‚Äôs quite a bit of looping going on in this implementation. Normally, that would be no issue. Python, however, is notoriously slow when it comes to looping. In my previous post about the <a href="https://www.peculiar-coding-endeavours.com/2023/game-of-life/" target="_blank">Game of Life</a>, I tackled that problem by using Numpy, Numba, and some search space optimizations. I decided not to take that route this time, however, since I didn‚Äôt want to make the implementation even more complex, and also give a fair comparison of all 4 algorithms without any trickery going into it. I will probably make a Rust ü¶Ä version at some point, probably without too many visuals going on (unless I get good at Bevy real fast), so the raw performance potential of several algorithms is more obvious. For now, though, bear with me (or Python, rather). I don‚Äôt execute the brute force and dynamic programming algorithms when the number of nodes exceeds 8 and 17 nodes, respectively, so things won‚Äôt be overly painful.</p>

<h3 id="genetic-algorithm">Genetic algorithm</h3>

<p>Finally, this is where the real fun starts‚Ä¶ Now that we have two ways of solving the TSP that give us a guaranteed optimal result, even though it might take a bit to get there, we‚Äôll dig into some approximation algorithms. Firstly, genetic algorithms. You will see that the code isn‚Äôt terribly complex at all, which allows me to focus on the high-level concepts of these interesting algorithms and apply them to this problem. If the dynamic programming section was a bit of a head-scratcher, no worries; it‚Äôs all fun and games from here on out.</p>

<h4 id="genetic-evolution">Genetic? Evolution?</h4>

<p>First and foremost, what are genetic algorithms..? They are an optimization technique, using concepts from evolutionary biology to search for a global optimal solution. As you would expect when drawing the analogy to evolution, we start with an initial population. We will crossbreed certain entities from the population with each other to obtain a new generation. There are various techniques we can apply to this process, and as you would expect, strong specimens will be more likely to breed, and some random mutations will also occur. As such, it really mimics the process of evolutionary biology, where we have non-random survival, with non-random selection, and random mutation. The survival of a certain specimen (or the spreading of its ‚Äògenes) is steered by a fitness function that measures how well it can optimize for its purpose (in our case, finding the shortest route between a set of nodes). Stronger specimens have a higher chance of propagating their DNA through the generations, as they are more likely to be chosen for reproduction. To make sure there is some sense of discovery built into the whole system, random mutation will be an important part of the process.</p>

<p>When I first read about these algorithms, I got incredibly excited to learn about them, take a swing at them myself, and I‚Äôm still amazed at how well the whole concept works. You will see that close to optimal results can be achieved very quickly, both in terms of generations needed to do so and in terms of processing time. Each step is fairly simple, very visual, and easy to implement. Most of the difficulty regarding the efficacy of these algorithms lies in the details and many of the parameters. How big is my population? How many generations will I evolve before I stop and accept the result as close enough to optimal? What techniques will I use to steer the crossbreeding? How will I introduce genetic mutations in new specimens? A lot of these questions are often a matter of experimentation. Since I‚Äôm still very much a beginner in terms of these algorithms, I‚Äôd encourage you to start your own learning journey if all of this spikes your interest. For now, let me show you the implementation I came up with after experimenting with all of the above:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">def</span> <span class="nf">genetic_algorithm</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span> <span class="n">population_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                            <span class="n">max_generations</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">max_no_improvement</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="n">AlgorithmResult</span><span class="p">]:</span>
    <span class="s">"""Solve the TSP problem with a genetic algorithm"""</span>
    <span class="n">generations_evaluated</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">generations_until_solved</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">generations_without_improvement</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">optimal_cycle</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">optimal_cycle_length</span> <span class="o">=</span> <span class="n">maxsize</span>
    <span class="n">population</span> <span class="o">=</span> <span class="n">spawn</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">population_size</span><span class="p">)</span>
    <span class="n">cycle_lengths</span> <span class="o">=</span> <span class="n">get_cycle_lengths</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_generations</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">generations_without_improvement</span> <span class="o">&gt;=</span> <span class="n">max_no_improvement</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="n">fitness</span> <span class="o">=</span> <span class="n">determine_fitness</span><span class="p">(</span><span class="n">cycle_lengths</span><span class="p">)</span>
        <span class="n">improved</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cycle_length</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cycle_lengths</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cycle_length</span> <span class="o">&lt;</span> <span class="n">optimal_cycle_length</span><span class="p">:</span>
                <span class="n">improved</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">optimal_cycle_length</span> <span class="o">=</span> <span class="n">cycle_length</span>
                <span class="n">optimal_cycle</span> <span class="o">=</span> <span class="n">population</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">generations_evaluated</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">improved</span><span class="p">:</span>
            <span class="n">generations_until_solved</span> <span class="o">=</span> <span class="n">generations_evaluated</span>
            <span class="n">generations_without_improvement</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">vertices</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">optimal_cycle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">optimal_cycle</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">distance</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">)]</span>
                <span class="n">vertices</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">distance</span><span class="p">))</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">key</span>
            <span class="n">graph</span><span class="p">.</span><span class="n">remove_vertices</span><span class="p">()</span>
            <span class="n">graph</span><span class="p">.</span><span class="n">add_vertices</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
            <span class="n">graph</span><span class="p">.</span><span class="n">optimal_cycle</span> <span class="o">=</span> <span class="n">ShortestPath</span><span class="p">(</span><span class="n">optimal_cycle_length</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">generations_without_improvement</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">population</span><span class="p">,</span> <span class="n">cycle_lengths</span> <span class="o">=</span> <span class="n">create_next_population</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">cycle_lengths</span><span class="p">,</span>
                                                           <span class="n">fitness</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.0001</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">AlgorithmResult</span><span class="p">(</span><span class="n">generations_evaluated</span><span class="p">,</span> <span class="n">generations_until_solved</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">AlgorithmResult</span><span class="p">(</span><span class="n">generations_evaluated</span><span class="p">,</span> <span class="n">generations_until_solved</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">spawn</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">population_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="s">"""Create the initial generation"""</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">key</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">max_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">factorial</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">unique_permutations</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_permutations</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">population_size</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_permutations</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_size</span><span class="p">:</span>
        <span class="n">permutation</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
        <span class="n">shuffle</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span>
        <span class="n">permutation</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">start</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">permutation</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unique_permutations</span><span class="p">:</span>
            <span class="n">unique_permutations</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span> <span class="k">for</span> <span class="n">permutation</span> <span class="ow">in</span> <span class="n">unique_permutations</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">create_next_population</span><span class="p">(</span><span class="n">current_population</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">cycle_lengths</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                           <span class="n">fitness</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span>
                           <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="s">"""Create the next generation"""</span>
    <span class="n">new_population</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">population_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_population</span><span class="p">)</span>

    <span class="c1"># Create the offspring of the current generation
</span>    <span class="n">offspring</span> <span class="o">=</span> <span class="n">create_offspring</span><span class="p">(</span><span class="n">current_population</span><span class="p">,</span> <span class="n">fitness</span><span class="p">,</span> <span class="n">population_size</span><span class="p">)</span>

    <span class="c1"># Perform a variation of elitism where we add the offspring to the current generation
</span>    <span class="c1"># and only continue with the fittest list of size population_size
</span>    <span class="n">new_population</span> <span class="o">=</span> <span class="n">current_population</span> <span class="o">+</span> <span class="n">offspring</span>
    <span class="n">offspring_cycle_lengths</span> <span class="o">=</span> <span class="n">get_cycle_lengths</span><span class="p">(</span><span class="n">offspring</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
    <span class="n">new_population_cycle_lengths</span> <span class="o">=</span> <span class="n">cycle_lengths</span> <span class="o">+</span> <span class="n">offspring_cycle_lengths</span>
    <span class="n">new_population_fitness</span> <span class="o">=</span> <span class="n">fitness</span> <span class="o">+</span> <span class="n">determine_fitness</span><span class="p">(</span><span class="n">offspring_cycle_lengths</span><span class="p">)</span>
    <span class="n">survivor_candidates</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_population_fitness</span><span class="p">,</span> <span class="n">new_population</span><span class="p">)</span>
    <span class="n">fittest_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">heapq</span><span class="p">.</span><span class="n">nlargest</span><span class="p">(</span><span class="n">population_size</span><span class="p">,</span> <span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">survivor_candidates</span><span class="p">)))]</span>
    <span class="n">new_population</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_population</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fittest_indices</span><span class="p">]</span>
    <span class="n">new_population_cycle_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_population_cycle_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fittest_indices</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">new_population</span><span class="p">,</span> <span class="n">new_population_cycle_lengths</span>


<span class="k">def</span> <span class="nf">create_offspring</span><span class="p">(</span><span class="n">current_population</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">fitness</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                     <span class="n">population_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="s">"""Create a new generation"""</span>
    <span class="n">offspring</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">offspring</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">population_size</span><span class="p">:</span>
        <span class="n">parent1</span> <span class="o">=</span> <span class="n">parent2</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">parent1</span> <span class="o">==</span> <span class="n">parent2</span><span class="p">:</span>
            <span class="n">parent1</span> <span class="o">=</span> <span class="n">get_parent</span><span class="p">(</span><span class="n">fitness</span><span class="p">)</span>
            <span class="n">parent2</span> <span class="o">=</span> <span class="n">get_parent</span><span class="p">(</span><span class="n">fitness</span><span class="p">)</span>

        <span class="n">child1</span> <span class="o">=</span> <span class="n">crossover</span><span class="p">(</span><span class="n">current_population</span><span class="p">[</span><span class="n">parent1</span><span class="p">],</span> <span class="n">current_population</span><span class="p">[</span><span class="n">parent2</span><span class="p">])</span>
        <span class="n">child2</span> <span class="o">=</span> <span class="n">crossover</span><span class="p">(</span><span class="n">current_population</span><span class="p">[</span><span class="n">parent2</span><span class="p">],</span> <span class="n">current_population</span><span class="p">[</span><span class="n">parent1</span><span class="p">])</span>

        <span class="n">child1</span> <span class="o">=</span> <span class="n">mutate</span><span class="p">(</span><span class="n">child1</span><span class="p">)</span>
        <span class="n">child2</span> <span class="o">=</span> <span class="n">mutate</span><span class="p">(</span><span class="n">child2</span><span class="p">)</span>

        <span class="n">offspring</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">child1</span><span class="p">)</span>
        <span class="n">offspring</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">child2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">offspring</span>


<span class="k">def</span> <span class="nf">get_parent</span><span class="p">(</span><span class="n">fitness</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]):</span>
    <span class="s">"""Get a parent using either tournament selection or biased random selection"""</span>
    <span class="k">if</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tournament_selection</span><span class="p">(</span><span class="n">fitness</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">biased_random_selection</span><span class="p">(</span><span class="n">fitness</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">tournament_selection</span><span class="p">(</span><span class="n">fitness</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="s">"""Perform basic tournament selection to get a parent"""</span>
    <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fitness</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">candidate1</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
    <span class="n">candidate2</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">candidate1</span> <span class="o">==</span> <span class="n">candidate2</span><span class="p">:</span>
        <span class="n">candidate2</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">candidate1</span> <span class="k">if</span> <span class="n">fitness</span><span class="p">[</span><span class="n">candidate1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">fitness</span><span class="p">[</span><span class="n">candidate2</span><span class="p">]</span> <span class="k">else</span> <span class="n">candidate2</span>


<span class="k">def</span> <span class="nf">biased_random_selection</span><span class="p">(</span><span class="n">fitness</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="s">"""Perform biased random selection to get a parent"""</span>
    <span class="n">random_specimen</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fitness</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fitness</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fitness</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">fitness</span><span class="p">[</span><span class="n">random_specimen</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">i</span>

    <span class="k">return</span> <span class="n">random_specimen</span>


<span class="k">def</span> <span class="nf">crossover</span><span class="p">(</span><span class="n">parent1</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">parent2</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="s">"""Cross-breed a new set of children from the given parents"""</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">parent1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">parent1</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">parent1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">parent1</span> <span class="o">=</span> <span class="n">parent1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">parent1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">parent2</span> <span class="o">=</span> <span class="n">parent2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">parent2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">split</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">child</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">split</span><span class="p">):</span>
        <span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="n">remainder</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">parent2</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">child</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">remainder</span><span class="p">):</span>
        <span class="n">child</span><span class="p">[</span><span class="n">split</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">start</span><span class="p">,</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="n">end</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">mutate</span><span class="p">(</span><span class="n">child</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="s">"""Mutate the child sequence"""</span>
    <span class="k">if</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">child</span> <span class="o">=</span> <span class="n">swap_mutate</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
    <span class="n">child</span> <span class="o">=</span> <span class="n">rotate_mutate</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">child</span>


<span class="k">def</span> <span class="nf">swap_mutate</span><span class="p">(</span><span class="n">child</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="s">"""Mutate the cycle by swapping 2 nodes"""</span>
    <span class="n">index1</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">index2</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">child</span><span class="p">[</span><span class="n">index1</span><span class="p">],</span> <span class="n">child</span><span class="p">[</span><span class="n">index2</span><span class="p">]</span> <span class="o">=</span> <span class="n">child</span><span class="p">[</span><span class="n">index2</span><span class="p">],</span> <span class="n">child</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">child</span>


<span class="k">def</span> <span class="nf">rotate_mutate</span><span class="p">(</span><span class="n">child</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="s">"""Mutate the cycle by rotating a part nodes"""</span>
    <span class="n">split</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">split</span><span class="p">]</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="n">child</span><span class="p">[</span><span class="n">split</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">tail</span> <span class="o">=</span> <span class="n">child</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="n">child</span> <span class="o">=</span> <span class="n">head</span> <span class="o">+</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">tail</span>

    <span class="k">return</span> <span class="n">child</span>


<span class="k">def</span> <span class="nf">get_cycle_lengths</span><span class="p">(</span><span class="n">population</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
                      <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="s">"""Get the lengths of all cycles in the graph"""</span>
    <span class="n">cycle_lengths</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">specimen</span> <span class="ow">in</span> <span class="n">population</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">specimen</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cycle_length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">specimen</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">cycle_length</span> <span class="o">+=</span> <span class="n">distances</span><span class="p">[(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">)]</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">key</span>
        <span class="n">cycle_lengths</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">cycle_length</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cycle_lengths</span>


<span class="k">def</span> <span class="nf">determine_fitness</span><span class="p">(</span><span class="n">cycle_lengths</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
    <span class="s">"""Determine the fitness of the specimens in the population"""</span>
    <span class="c1"># Invert so that shorter paths get higher values
</span>    <span class="n">fitness_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cycle_lengths</span><span class="p">)</span>
    <span class="n">fitness</span> <span class="o">=</span> <span class="p">[</span><span class="n">fitness_sum</span> <span class="o">/</span> <span class="n">cycle_length</span> <span class="k">for</span> <span class="n">cycle_length</span> <span class="ow">in</span> <span class="n">cycle_lengths</span><span class="p">]</span>

    <span class="c1"># Normalize the fitness
</span>    <span class="n">fitness_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">fitness</span><span class="p">)</span>
    <span class="n">fitness</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="o">/</span> <span class="n">fitness_sum</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fitness</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">fitness</span>
</code></pre></div></div>

<h4 id="the-initial-population">The initial population</h4>

<p>If you take your time to go over the implementation and maybe step through it yourself, I think your first impression will be that the complexity here is fairly low. Let‚Äôs go over what exactly happens, and focus on some of the functions in detail. Our first task is to spawn an initial population:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">population</span> <span class="o">=</span> <span class="n">spawn</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">population_size</span><span class="p">)</span>
<span class="p">...</span>
<span class="k">def</span> <span class="nf">spawn</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">population_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="s">"""Create the initial generation"""</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">key</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">max_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">factorial</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">unique_permutations</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_permutations</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">population_size</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_permutations</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_size</span><span class="p">:</span>
        <span class="n">permutation</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
        <span class="n">shuffle</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span>
        <span class="n">permutation</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">start</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">permutation</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unique_permutations</span><span class="p">:</span>
            <span class="n">unique_permutations</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span> <span class="k">for</span> <span class="n">permutation</span> <span class="ow">in</span> <span class="n">unique_permutations</span><span class="p">]</span>
</code></pre></div></div>

<p>So what does it mean to have a ‚Äúpopulation‚Äù? For our particular problem, each specimen in the population is basically a candidate route that starts out at our designated starting node, visits every other node exactly once, and arrives back at that starting node. Whether or not that‚Äôs an optimal route or not is of no significance at this point. We trust that an approximation of the ideal route can be achieved through evolution, and we won‚Äôt have to perform an exhaustive search through all permutations. That last part is the whole point of it, especially for problems that are NP-hard: we do not want to generate the full set of potential solutions and go through them one by one. We will simply generate a number of candidate solutions and start the process from there. Also, it‚Äôs important that these initial candidate solutions be chosen randomly. When we use heuristics to already pre-optimize candidates, this leads to low diversity in the population, which can yield suboptimal solutions. There is no need to increase the initial fitness of the population. It‚Äôs the diversity of the solutions that will lead to optimality.</p>

<p>That begs another question: how do we determine the size of our initial population? If we start with a high initial population count, this can cause the algorithm to perform very poorly, which we want to avoid. Then again, an overly small population may not be enough to create a high-quality and diverse mating pool. A lot of trial and error can go into finding a population size that suits the specific problem. In this case, I have settled on half of n!, where n is the set of nodes excluding the starting node. For example, if we have a set of 8 total nodes, the initial population size would consist of (7!) / 2 = 2520. Putting it in perspective, in this case, there would be 40320 potential solutions, so we‚Äôre still far from generating the full set of candidates. In case you want to learn more, there are several whitepapers out there that just focus on techniques to determine the ideal initial population size.</p>

<h4 id="keep-on-spinning-forever">Keep on spinning forever?</h4>

<p>So now that we have decided on an initial population, the next question is: how long will we keep this little ecosystem doing its thing? Remember two sentences back? Yeah, there‚Äôs also enough research going on regarding that question. At some point, there is simply no improvement possible since we converged on the optimal solution, or the whole cycle doesn‚Äôt yield any improvement anymore. Since we‚Äôll never know whether we actually found an optimal solution (not without some ‚Äúhelp‚Äù from the outside at least), we‚Äôll just decide to stop running the algorithm when we haven‚Äôt seen any improvement for a certain number of generations:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_generations</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">generations_without_improvement</span> <span class="o">&gt;=</span> <span class="n">max_no_improvement</span><span class="p">:</span>
            <span class="k">break</span>
</code></pre></div></div>

<p>What that number is will be dependent on the size of the problem and many other factors. In main.py, you see that some experimentation made me settle on some numbers of population size and max_generations that seemed to work well for a certain number of nodes:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">__determine_ga_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="n">match</span> <span class="n">node_count</span><span class="p">:</span>
            <span class="n">case</span> <span class="n">_</span> <span class="k">if</span> <span class="n">node_count</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">return</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">5</span>
            <span class="n">case</span> <span class="n">_</span> <span class="k">if</span> <span class="n">node_count</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">:</span> <span class="k">return</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">10</span>
            <span class="n">case</span> <span class="n">_</span> <span class="k">if</span> <span class="n">node_count</span> <span class="o">&lt;=</span> <span class="mi">15</span><span class="p">:</span> <span class="k">return</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">30</span>
            <span class="n">case</span> <span class="n">_</span> <span class="k">if</span> <span class="n">node_count</span> <span class="o">&lt;=</span> <span class="mi">20</span><span class="p">:</span> <span class="k">return</span> <span class="mi">750</span><span class="p">,</span> <span class="mi">50</span>
            <span class="n">case</span> <span class="n">_</span> <span class="k">if</span> <span class="n">node_count</span> <span class="o">&lt;=</span> <span class="mi">25</span><span class="p">:</span> <span class="k">return</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">75</span>
            <span class="n">case</span> <span class="n">_</span> <span class="k">if</span> <span class="n">node_count</span> <span class="o">&lt;=</span> <span class="mi">30</span><span class="p">:</span> <span class="k">return</span> <span class="mi">1250</span><span class="p">,</span> <span class="mi">100</span>
            <span class="n">case</span> <span class="n">_</span> <span class="k">if</span> <span class="n">node_count</span> <span class="o">&lt;=</span> <span class="mi">35</span><span class="p">:</span> <span class="k">return</span> <span class="mi">1500</span><span class="p">,</span> <span class="mi">150</span>
            <span class="n">case</span> <span class="n">_</span> <span class="k">if</span> <span class="n">node_count</span> <span class="o">&lt;=</span> <span class="mi">50</span><span class="p">:</span> <span class="k">return</span> <span class="mi">5000</span><span class="p">,</span> <span class="mi">250</span>
        <span class="k">return</span> <span class="mi">25000</span><span class="p">,</span> <span class="mi">500</span>
</code></pre></div></div>

<h4 id="nature-calls">Nature calls</h4>

<p>And after that, you could say it‚Äôs off to the races. We first determine the fitness of our current population, which is fairly simple. All we do is take the total sum of the cycle lengths and divide the length of each cycle by that number. That way, shorter paths get higher values. We then just normalize those values so they all sum up to 1.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">determine_fitness</span><span class="p">(</span><span class="n">cycle_lengths</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
    <span class="s">"""Determine the fitness of the specimens in the population"""</span>
    <span class="c1"># Invert so that shorter paths get higher values
</span>    <span class="n">fitness_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cycle_lengths</span><span class="p">)</span>
    <span class="n">fitness</span> <span class="o">=</span> <span class="p">[</span><span class="n">fitness_sum</span> <span class="o">/</span> <span class="n">cycle_length</span> <span class="k">for</span> <span class="n">cycle_length</span> <span class="ow">in</span> <span class="n">cycle_lengths</span><span class="p">]</span>

    <span class="c1"># Normalize the fitness
</span>    <span class="n">fitness_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">fitness</span><span class="p">)</span>
    <span class="n">fitness</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="o">/</span> <span class="n">fitness_sum</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fitness</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">fitness</span>
</code></pre></div></div>

<p>After this step, we check if we found a shorter cycle in this generation and update the shortest known cycle to that specific candidate. We then do some bookkeeping to update our graph to reflect this newly found solution, which is just something we do for this particular project in order to display intermediary results. The next important thing we need to do is create a whole new generation. There are a lot of possibilities to experiment with here, from the methods for selection to the way we introduce mutation, and even the size of the new population.</p>

<h4 id="non-random-selection">Non-random selection</h4>

<p>What determines which specimens get to propagate their DNA through the generations? The temptation might be to simply select only the strongest candidate solutions. This will inevitably lead to getting stuck in local optimal solutions, low diversity in the population, and ultimately, far from a close-to-optimal solution in the long run. There are two quite popular methods for selecting parents: tournament selection and biased random selection. We will randomly select either one of them. If you think: ‚Äúthat sounds awefully random to me; where does the non-random part come in?‚Äù no worries, both still favor more fit specimens.</p>

<p>Tournament selection works as follows: we pick two completely random candidate solutions out of the population, and whichever has the highest fitness wins. Yeah. That‚Äôs it. I told you the code was simple. Here it is:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">tournament_selection</span><span class="p">(</span><span class="n">fitness</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="s">"""Perform basic tournament selection to get a parent"""</span>
    <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fitness</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">candidate1</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
    <span class="n">candidate2</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">candidate1</span> <span class="o">==</span> <span class="n">candidate2</span><span class="p">:</span>
        <span class="n">candidate2</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">candidate1</span> <span class="k">if</span> <span class="n">fitness</span><span class="p">[</span><span class="n">candidate1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">fitness</span><span class="p">[</span><span class="n">candidate2</span><span class="p">]</span> <span class="k">else</span> <span class="n">candidate2</span>
</code></pre></div></div>

<p>As an alternative, biased random selection works a bit differently. We select a random specimen, and we look for the first specimen in the list that has a higher fitness score than that random one. If we find it. If not, the initially randomly selected specimen is the one that will return. Quite literally random, but‚Ä¶ biased.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">biased_random_selection</span><span class="p">(</span><span class="n">fitness</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="s">"""Perform biased random selection to get a parent"""</span>
    <span class="n">random_specimen</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fitness</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fitness</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fitness</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">fitness</span><span class="p">[</span><span class="n">random_specimen</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">i</span>

    <span class="k">return</span> <span class="n">random_specimen</span>
</code></pre></div></div>

<h4 id="crossover">Crossover</h4>

<p>Great, so now we have two parents. We all know what comes next. Detail: we don‚Äôt have to limit ourselves to only 2 parents in the case of crossover during genetic algorithms, there‚Äôs no reason why we would not use 3/4 or more parents when creating a new specimen for the next generation (also, wipe that smirk off your face). In this case, let‚Äôs be nice about it and stick to two parents. Our crossover function looks as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">crossover</span><span class="p">(</span><span class="n">parent1</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">parent2</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="s">"""Cross-breed a new set of children from the given parents"""</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">parent1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">parent1</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">parent1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">parent1</span> <span class="o">=</span> <span class="n">parent1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">parent1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">parent2</span> <span class="o">=</span> <span class="n">parent2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">parent2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">split</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">child</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">split</span><span class="p">):</span>
        <span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="n">remainder</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">parent2</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">child</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">remainder</span><span class="p">):</span>
        <span class="n">child</span><span class="p">[</span><span class="n">split</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">start</span><span class="p">,</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="n">end</span><span class="p">]</span>
</code></pre></div></div>

<p>‚ÄúA part of mommy, a part of dad‚Äù. It sounds clumsily simple, but that is really all there is to it. We take a part of the first parent and assign it to our offspring. That ‚Äúpart‚Äù, in case you are wondering, is just the start of the route as described by the parent specimen. A certain sequence of nodes, starting from our designated starting node, up to some cut-off point that is randomly decided on. That is basically our DNA. After this, we need to complete the route from the cut-off point back to the starting node. In this case, though, we need to respect the problem at hand and make sure we only visit each node once. So we loop through the nodes of parent2 and only add each node to the child if it has not been visited yet. You could say that potentially scrambles up the second part of the offspring candidate, and that is true. We literally take the exact sequence of nodes of parent1 up to the cut-off point but will not respect the sequence of nodes of parent2 as we add them to the child.</p>

<h4 id="mutation">Mutation</h4>

<p>As we all know, biology isn‚Äôt perfect, so let‚Äôs include some random mutations just like they happen in nature. After generating our offspring per parent pair, we mutate them using one of two possible methods. Swap mutate, and rotate mutate. Why introduce mutations at all? We want to maintain genetic diversity in our population so we don‚Äôt get stuck in local mimima. Usually, in genetic algorithms, mutation is only done sporadically. Here, you see that I mutate every single offspring specimen. Experiment yourself when implementing genetic algorithms for your specific problem to see what works and what doesn‚Äôt.</p>

<p>Swap mutate is a really simple and low-impact mutation that will simply swap 2 nodes in the sequence, and it looks like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">swap_mutate</span><span class="p">(</span><span class="n">child</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="s">"""Mutate the cycle by swapping 2 nodes"""</span>
    <span class="n">index1</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">index2</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">child</span><span class="p">[</span><span class="n">index1</span><span class="p">],</span> <span class="n">child</span><span class="p">[</span><span class="n">index2</span><span class="p">]</span> <span class="o">=</span> <span class="n">child</span><span class="p">[</span><span class="n">index2</span><span class="p">],</span> <span class="n">child</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">child</span>
</code></pre></div></div>

<p>On the other hand, rotate mutation really scrambles up the specimen. We chose a split point, excluding the start node, and divided our sequence into a head, mid, and tail. We then completely reversed the mid, and reconstruct the sequence. This adds quite some diversity to the population.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">rotate_mutate</span><span class="p">(</span><span class="n">child</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="s">"""Mutate the cycle by rotating a part nodes"""</span>
    <span class="n">split</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">split</span><span class="p">]</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="n">child</span><span class="p">[</span><span class="n">split</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">tail</span> <span class="o">=</span> <span class="n">child</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="n">child</span> <span class="o">=</span> <span class="n">head</span> <span class="o">+</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">tail</span>

    <span class="k">return</span> <span class="n">child</span>
</code></pre></div></div>

<p>And that is all there is to it. As a reminder, the full create_offspring function, with all these building blocks put together, looks like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">create_offspring</span><span class="p">(</span><span class="n">current_population</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">fitness</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                     <span class="n">population_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="s">"""Create a new generation"""</span>
    <span class="n">offspring</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">offspring</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">population_size</span><span class="p">:</span>
        <span class="n">parent1</span> <span class="o">=</span> <span class="n">parent2</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">parent1</span> <span class="o">==</span> <span class="n">parent2</span><span class="p">:</span>
            <span class="n">parent1</span> <span class="o">=</span> <span class="n">get_parent</span><span class="p">(</span><span class="n">fitness</span><span class="p">)</span>
            <span class="n">parent2</span> <span class="o">=</span> <span class="n">get_parent</span><span class="p">(</span><span class="n">fitness</span><span class="p">)</span>

        <span class="n">child1</span> <span class="o">=</span> <span class="n">crossover</span><span class="p">(</span><span class="n">current_population</span><span class="p">[</span><span class="n">parent1</span><span class="p">],</span> <span class="n">current_population</span><span class="p">[</span><span class="n">parent2</span><span class="p">])</span>
        <span class="n">child2</span> <span class="o">=</span> <span class="n">crossover</span><span class="p">(</span><span class="n">current_population</span><span class="p">[</span><span class="n">parent2</span><span class="p">],</span> <span class="n">current_population</span><span class="p">[</span><span class="n">parent1</span><span class="p">])</span>

        <span class="n">child1</span> <span class="o">=</span> <span class="n">mutate</span><span class="p">(</span><span class="n">child1</span><span class="p">)</span>
        <span class="n">child2</span> <span class="o">=</span> <span class="n">mutate</span><span class="p">(</span><span class="n">child2</span><span class="p">)</span>

        <span class="n">offspring</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">child1</span><span class="p">)</span>
        <span class="n">offspring</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">child2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">offspring</span>
</code></pre></div></div>

<p>Now that we focused on each individual step, the complete function is very simple to understand. We simply keep pairing up two selected parents, create two children per parent, apply mutation to each of them, and add them to the new generation.</p>

<h4 id="lets-get-fancy-about-it">Let‚Äôs get fancy about it</h4>

<p>Just one more thing, though. We did create a whole new generation of candidate solutions, equal in size to the previous generation. We introduced a bunch of randomization along the way, both in the selection of parents as well as in how their DNA was propagated to the next generation. And just like in nature, the parents have now played their parts, and they die a lonely death, assured in the knowledge that all that was best about them lives on in their children as they wither away. Wait, that got way too grim, way too fast. Also, this isn‚Äôt nature. Or is it? We‚Äôre still playing survival of the fittest, and there‚Äôs no need to brush aside our strong performers just because we‚Äôve got a new generation waiting to take over.</p>

<p>So we‚Äôll introduce another little technique called elitism, which is implemented as such:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">new_population</span> <span class="o">=</span> <span class="n">current_population</span> <span class="o">+</span> <span class="n">offspring</span>
    <span class="n">offspring_cycle_lengths</span> <span class="o">=</span> <span class="n">get_cycle_lengths</span><span class="p">(</span><span class="n">offspring</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
    <span class="n">new_population_cycle_lengths</span> <span class="o">=</span> <span class="n">cycle_lengths</span> <span class="o">+</span> <span class="n">offspring_cycle_lengths</span>
    <span class="n">new_population_fitness</span> <span class="o">=</span> <span class="n">fitness</span> <span class="o">+</span> <span class="n">determine_fitness</span><span class="p">(</span><span class="n">offspring_cycle_lengths</span><span class="p">)</span>
    <span class="n">survivor_candidates</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_population_fitness</span><span class="p">,</span> <span class="n">new_population</span><span class="p">)</span>
    <span class="n">fittest_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">heapq</span><span class="p">.</span><span class="n">nlargest</span><span class="p">(</span><span class="n">population_size</span><span class="p">,</span> <span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">survivor_candidates</span><span class="p">)))]</span>
    <span class="n">new_population</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_population</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fittest_indices</span><span class="p">]</span>
    <span class="n">new_population_cycle_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_population_cycle_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fittest_indices</span><span class="p">]</span>
</code></pre></div></div>

<p>We simply add the new generation of offspring to the current generation. And then we execute our fitness function again. If you‚Äôre a visual thinker, imagine we‚Äôre having ourselves a good old brawl that will knock out half of the population, leaving the strongest ones standing. It‚Äôs these specimens that we‚Äôll keep on board to continue the algorithm. Also, notice we‚Äôre using a priority queue, which has a max binary heap implementation under the hood to only select the best x largest of elements without having to order the full list. I actually implemented that myself <a href="https://www.peculiar-coding-endeavours.com/2020/through-the-trees/" target="_blank">here</a> - well it‚Äôs a min binary heap there, same idea though - before I knew that there was an implementation built-in üòâ Still, I strongly believe that you should know about and be able to implement these kinds of basic data structures on your own. Don‚Äôt depend on others to do all the thinking for you. I always valued fundamentals, algorithms, and data structures way more than cobbling together packages and frameworks. And it seems like, in these ChatGPT times where example implementations of frameworks are a prompt away, that‚Äôll be even more useful than ever.</p>

<p>In any case, that‚Äôs all in terms of implementation. As I said before, the code isn‚Äôt really that involved at all, and each step can be easily visualized. This is only a very basic implementation, though, and there‚Äôs so much to uncover about genetic algorithms, techniques to perform crossover, selection, mutation, optimization of the parameters and so much more. I hope this small example does trigger your interest to start researching more about them. It‚Äôs really quite wonderful how such a simple concept can yield very good results in a short time.</p>

<h3 id="thousands-of-little-creepers">Thousands of little creepers‚Ä¶</h3>

<p>Talking about wonderful‚Ä¶ The next algorithm got me even more excited than genetic algorithms. We‚Äôll stick to nature, but switch gears from the wonders of evolution to the behavior of one of the most numerous animals on the planet: ants! I was extremely excited to dig my fingers into this one, and I hope it will get you equally excited. Ant colony optimization is a very interesting algorithm where we mimic the behavior of ant swarms. We will unleash a number of waves of ants onto our starting node and have them explore our graph until they visit all nodes and end up back at the starting node. As they explore the graph, they leave behind a pheromone trail that will encourage other ants to also take that route. The better (shorter, in our case) a route is, the stronger the pheromone trail, and the more chance there is that another ant will prefer to take that route, leaving behind additional pheromones to further strengthen that path. To also introduce some sense of exploration and to avoid local minima, pheromones will evaporate over time. While getting myself familiar with the overall concept and the details behind it, several clips of HK Lam, <a href="https://www.youtube.com/watch?v=jNd7QJQH-kk" target="_blank">like this one and others</a> helped my understanding tremendously. He has playlists on several interesting topics in the same sphere, definitely check them out! The full code of the algorithm:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">def</span> <span class="nf">ant_colony</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span>
                     <span class="n">max_swarms</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">max_no_improvement</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="n">AlgorithmResult</span><span class="p">]:</span>
    <span class="s">"""Solve the TSP problem using ant colony optimization"""</span>
    <span class="n">swarms_evaluated</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">evaluations_until_solved</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">swarms_without_improvement</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">node_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">.</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">pheromones</span> <span class="o">=</span> <span class="n">initialize_pheromones</span><span class="p">(</span><span class="n">node_count</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_swarms</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">swarms_without_improvement</span> <span class="o">&gt;=</span> <span class="n">max_no_improvement</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="n">vertices</span><span class="p">,</span> <span class="n">cycle_lengths</span> <span class="o">=</span> <span class="n">swarm_traversal</span><span class="p">(</span><span class="n">pheromones</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
        <span class="n">pheromones</span> <span class="o">=</span> <span class="n">pheromone_evaporation</span><span class="p">(</span><span class="n">pheromones</span><span class="p">)</span>
        <span class="n">best_cycle_index</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">cycle_lengths</span><span class="p">)</span>
        <span class="n">best_cycle</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">best_cycle_index</span><span class="p">]</span>
        <span class="n">best_cycle_length</span> <span class="o">=</span> <span class="n">cycle_lengths</span><span class="p">[</span><span class="n">best_cycle_index</span><span class="p">]</span>
        <span class="n">pheromones</span> <span class="o">=</span> <span class="n">pheromone_release</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">best_cycle</span><span class="p">,</span> <span class="n">best_cycle_length</span><span class="p">,</span> <span class="n">pheromones</span><span class="p">)</span>
        <span class="n">pheromones</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">pheromones</span><span class="p">)</span>
        <span class="n">swarms_evaluated</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">cycle_lengths</span><span class="p">[</span><span class="n">best_cycle_index</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">graph</span><span class="p">.</span><span class="n">optimal_cycle_length</span><span class="p">:</span>
            <span class="n">graph</span><span class="p">.</span><span class="n">remove_vertices</span><span class="p">()</span>
            <span class="n">graph</span><span class="p">.</span><span class="n">add_vertices</span><span class="p">(</span><span class="n">best_cycle</span><span class="p">)</span>
            <span class="n">graph</span><span class="p">.</span><span class="n">optimal_cycle</span> <span class="o">=</span> <span class="n">ShortestPath</span><span class="p">(</span><span class="n">best_cycle_length</span><span class="p">,</span> <span class="n">best_cycle</span><span class="p">)</span>
            <span class="n">evaluations_until_solved</span> <span class="o">=</span> <span class="n">swarms_evaluated</span>
            <span class="n">swarms_without_improvement</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.0001</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">AlgorithmResult</span><span class="p">(</span><span class="n">swarms_evaluated</span><span class="p">,</span> <span class="n">evaluations_until_solved</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">swarms_without_improvement</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">yield</span> <span class="n">AlgorithmResult</span><span class="p">(</span><span class="n">swarms_evaluated</span><span class="p">,</span> <span class="n">evaluations_until_solved</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">initialize_pheromones</span><span class="p">(</span><span class="n">node_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="s">"""Initialize the pheromone array"""</span>
    <span class="n">pheromones</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">node_count</span><span class="p">,</span> <span class="n">node_count</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="p">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">pheromones</span><span class="p">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
            <span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">):</span>
        <span class="n">row_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">row_sum</span> <span class="o">/</span> <span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="n">row_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/=</span> <span class="n">row_sum</span>
    <span class="k">return</span> <span class="n">pheromones</span>


<span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">pheromones</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="s">"""Normalize the pheromone matrix into probabilities"""</span>
    <span class="n">node_count</span> <span class="o">=</span> <span class="n">pheromones</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">):</span>
        <span class="n">row_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/=</span> <span class="n">row_sum</span>
    <span class="k">return</span> <span class="n">pheromones</span>


<span class="k">def</span> <span class="nf">swarm_traversal</span><span class="p">(</span><span class="n">pheromones</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="s">"""Traverse the graph with a number of ants equal to the number of nodes"""</span>
    <span class="n">node_count</span> <span class="o">=</span> <span class="n">pheromones</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">swarm_size</span> <span class="o">=</span> <span class="n">node_count</span> <span class="o">*</span> <span class="n">node_count</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">node_count</span><span class="p">]</span> <span class="o">*</span> <span class="n">swarm_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">"i,i,i"</span><span class="p">)</span>
    <span class="n">cycle_lengths</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">swarm_size</span>
    <span class="c1"># Traverse the graph swarm_size times
</span>    <span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">swarm_size</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
        <span class="n">futures</span> <span class="o">=</span> <span class="p">[</span><span class="n">executor</span><span class="p">.</span><span class="n">submit</span><span class="p">(</span><span class="n">traverse</span><span class="p">,</span> <span class="n">node_count</span><span class="p">,</span> <span class="n">pheromones</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">swarm_size</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">completed</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">as_completed</span><span class="p">(</span><span class="n">futures</span><span class="p">)):</span>
            <span class="n">cycle_length</span><span class="p">,</span> <span class="n">cycle</span> <span class="o">=</span> <span class="n">completed</span><span class="p">.</span><span class="n">result</span><span class="p">()</span>
            <span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cycle</span>
            <span class="n">cycle_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cycle_length</span>
    <span class="k">return</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">cycle_lengths</span>


<span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">node_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">pheromones</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
             <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="s">"""Perform a traversal through the graph"""</span>
    <span class="c1"># Each traversal consists of node_count vertices
</span>    <span class="n">current_node</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">current_node</span><span class="p">])</span>
    <span class="n">cycle_length</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">node_count</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">"i,i,i"</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">row_sorted_indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">pheromones</span><span class="p">[</span><span class="n">current_node</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="n">pheromones</span><span class="p">[</span><span class="n">current_node</span><span class="p">,</span> <span class="p">:],</span> <span class="n">row_sorted_indices</span><span class="p">)</span>
        <span class="n">cumul</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">row</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">cumul</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">cumul</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">cumul</span>

        <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">chance</span> <span class="o">=</span> <span class="n">random</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)):</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="n">row_sorted_indices</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">chance</span> <span class="o">&lt;=</span> <span class="n">row</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">and</span> <span class="n">candidate</span> <span class="o">!=</span> <span class="n">current_node</span> <span class="ow">and</span> <span class="n">candidate</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">candidate</span>
                <span class="k">break</span>
        <span class="c1"># If no suitable index was found, the generated chance was probably too low
</span>        <span class="c1"># Pick the first index that's not itself and not visited yet
</span>        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">candidate</span> <span class="o">=</span> <span class="n">row_sorted_indices</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">candidate</span> <span class="o">!=</span> <span class="n">current_node</span> <span class="ow">and</span> <span class="n">candidate</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">candidate</span>
                    <span class="k">break</span>

        <span class="n">distance</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">current_node</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span>
        <span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_node</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">distance</span><span class="p">)</span>
        <span class="n">cycle_length</span> <span class="o">+=</span> <span class="n">distance</span>
        <span class="n">visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">current_node</span> <span class="o">=</span> <span class="n">index</span>
    <span class="c1"># Add the last vertex back to the starting node
</span>    <span class="n">distance</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">current_node</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">vertices</span><span class="p">[</span><span class="n">node_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_node</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">distance</span><span class="p">)</span>
    <span class="n">cycle_length</span> <span class="o">+=</span> <span class="n">distance</span>
    <span class="k">return</span> <span class="n">cycle_length</span><span class="p">,</span> <span class="n">vertices</span>


<span class="k">def</span> <span class="nf">pheromone_evaporation</span><span class="p">(</span><span class="n">pheromones</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="s">"""Evaporation of pheromones after each traversal"""</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">np</span><span class="p">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">pheromones</span><span class="p">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="n">pheromones</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">pheromones</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">pheromones</span>


<span class="k">def</span> <span class="nf">pheromone_release</span><span class="p">(</span><span class="n">vertices</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">best_cycle</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
                      <span class="n">best_cycle_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">pheromones</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="s">"""Perform pheromone release, with elitism towards shorter cycles"""</span>
    <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">cycle</span><span class="p">:</span>
            <span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">weight</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">best_cycle</span><span class="p">:</span>
        <span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">best_cycle_length</span>

    <span class="k">return</span> <span class="n">pheromones</span>
</code></pre></div></div>

<h4 id="follow-the-crumbs-or-pheromones-really">Follow the crumbs, or pheromones really‚Ä¶</h4>

<p>You‚Äôll notice we use similar ideas as we did for the genetic algorithm. We‚Äôll exit when we have a certain amount of swarm traversals without improvement in terms of finding better routes, and parameters such as the number of swarms and the size of a swarm are very much subject to trial and error. Just like we initialized a starting generation to kick off the genetic algorithm, we‚Äôll have some initialization going on here, namely the pheromone matrix that will drive the behavior of the ants as they choose a certain route.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize_pheromones</span><span class="p">(</span><span class="n">node_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="s">"""Initialize the pheromone array"""</span>
    <span class="n">pheromones</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">node_count</span><span class="p">,</span> <span class="n">node_count</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="p">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">pheromones</span><span class="p">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
            <span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">):</span>
        <span class="n">row_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">row_sum</span> <span class="o">/</span> <span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="n">row_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/=</span> <span class="n">row_sum</span>
    <span class="k">return</span> <span class="n">pheromones</span>
</code></pre></div></div>

<p>We fill up a NxN matrix with zeros, where N is the number of nodes to visit. Then we add the distances from each node to each other node to that matrix. After that, we simply normalize these distances for each row into probabilities, just like we did for the genetic algorithm. Shorter distances between two nodes will result in a higher probability of that path being chosen. It‚Äôs really quite simple, and once that concept clicks with you, it‚Äôs not hard to imagine what follows. We will use this pheromone matrix to influence the routes that the ants take. Whenever an ant is at a node, their decision for the next node to go to depends on whether that node has already been visited and the probability assigned to that node.</p>

<h4 id="unleashing-the-swarms">Unleashing the swarms</h4>

<p>Now that our initial pheromone matrix is set up, we‚Äôll let loose a swarm of ants on the starting node and have them traverse the entire graph. They will each visit every node exactly once, and end up back at the starting node. The amount of ants in a swarm is up for debate and theoretical discussion, but we‚Äôll limit ourselves to n¬≤ ants per swarm. We spin up a number of threads to process each swarm traversal and collect the results of each traversal, which are the cycle lengths and the vertices traveled in sequence.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">swarm_traversal</span><span class="p">(</span><span class="n">pheromones</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="s">"""Traverse the graph with a number of ants equal to the number of nodes"""</span>
    <span class="n">node_count</span> <span class="o">=</span> <span class="n">pheromones</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">swarm_size</span> <span class="o">=</span> <span class="n">node_count</span> <span class="o">*</span> <span class="n">node_count</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">node_count</span><span class="p">]</span> <span class="o">*</span> <span class="n">swarm_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">"i,i,i"</span><span class="p">)</span>
    <span class="n">cycle_lengths</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">swarm_size</span>
    <span class="c1"># Traverse the graph swarm_size times
</span>    <span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">swarm_size</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
        <span class="n">futures</span> <span class="o">=</span> <span class="p">[</span><span class="n">executor</span><span class="p">.</span><span class="n">submit</span><span class="p">(</span><span class="n">traverse</span><span class="p">,</span> <span class="n">node_count</span><span class="p">,</span> <span class="n">pheromones</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">swarm_size</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">completed</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">as_completed</span><span class="p">(</span><span class="n">futures</span><span class="p">)):</span>
            <span class="n">cycle_length</span><span class="p">,</span> <span class="n">cycle</span> <span class="o">=</span> <span class="n">completed</span><span class="p">.</span><span class="n">result</span><span class="p">()</span>
            <span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cycle</span>
            <span class="n">cycle_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cycle_length</span>
    <span class="k">return</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">cycle_lengths</span>
</code></pre></div></div>

<p>Each traversal is simply a sequence of decisions going from one node to the next. We use the pheromone matrix to help us determine which candidate we will visit next. We generate a random number between 0 and 1 and loop over all candidates. We compare the generated random probability to each candidate (in the row in the pheromone matrix for that node, sorted to make this selection possible), and the first node we find that has a probability high enough to satisfy the generated number is the one we will go for (if it has not been visited already or is equal to the actual node we are at). As a fallback, we just take the first node that has not been visited yet. The code looks more involved than what is actually behind it, and there are undeniably more terse ways to express this, but this code allows you to follow along much easier if you decide to step through the code yourself.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">node_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">pheromones</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
             <span class="n">distances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="s">"""Perform a traversal through the graph"""</span>
    <span class="c1"># Each traversal consists of node_count vertices
</span>    <span class="n">current_node</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">current_node</span><span class="p">])</span>
    <span class="n">cycle_length</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">node_count</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">"i,i,i"</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">row_sorted_indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">pheromones</span><span class="p">[</span><span class="n">current_node</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="n">pheromones</span><span class="p">[</span><span class="n">current_node</span><span class="p">,</span> <span class="p">:],</span> <span class="n">row_sorted_indices</span><span class="p">)</span>
        <span class="n">cumul</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">row</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">cumul</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">cumul</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">cumul</span>

        <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">chance</span> <span class="o">=</span> <span class="n">random</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)):</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="n">row_sorted_indices</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">chance</span> <span class="o">&lt;=</span> <span class="n">row</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">and</span> <span class="n">candidate</span> <span class="o">!=</span> <span class="n">current_node</span> <span class="ow">and</span> <span class="n">candidate</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">candidate</span>
                <span class="k">break</span>
        <span class="c1"># If no suitable index was found, the generated chance was probably too low
</span>        <span class="c1"># Pick the first index that's not itself and not visited yet
</span>        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">candidate</span> <span class="o">=</span> <span class="n">row_sorted_indices</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">candidate</span> <span class="o">!=</span> <span class="n">current_node</span> <span class="ow">and</span> <span class="n">candidate</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">candidate</span>
                    <span class="k">break</span>

        <span class="n">distance</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">current_node</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span>
        <span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_node</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">distance</span><span class="p">)</span>
        <span class="n">cycle_length</span> <span class="o">+=</span> <span class="n">distance</span>
        <span class="n">visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">current_node</span> <span class="o">=</span> <span class="n">index</span>
    <span class="c1"># Add the last vertex back to the starting node
</span>    <span class="n">distance</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">current_node</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">vertices</span><span class="p">[</span><span class="n">node_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_node</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">distance</span><span class="p">)</span>
    <span class="n">cycle_length</span> <span class="o">+=</span> <span class="n">distance</span>
    <span class="k">return</span> <span class="n">cycle_length</span><span class="p">,</span> <span class="n">vertices</span>
</code></pre></div></div>

<p>Once we find the next node to visit, we simply add that to the set of already visited nodes so we can avoid visiting the same node twice. At the end, we simply make the last hop back to our starting node and return the completed cycle and its length.</p>

<h4 id="pheromone-release-and-evaporation">Pheromone release and evaporation</h4>

<p>After each traversal, we are hopefully a bit wiser as to which sequence of nodes results in a more ideal path. However, ants wouldn‚Äôt be ants if there wasn‚Äôt some sort of overarching mechanism to guide the whole swarm to more desirable circumstances. The pheromone matrix we initialized at the start will enable us to do just that. Based on the results of each traversal, we can implement a kind of feedback loop back into the swarm that will guide us to make even better decisions the next time we decide to make the journey. The functions pheromone_evaporation and pheromone_release do exactly that. Let‚Äôs look at each of them, starting with pheromone evaporation:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">pheromone_evaporation</span><span class="p">(</span><span class="n">pheromones</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="s">"""Evaporation of pheromones after each traversal"""</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">np</span><span class="p">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">pheromones</span><span class="p">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="n">pheromones</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">pheromones</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">pheromones</span>
</code></pre></div></div>

<p>Why would we want to dissolve the pheromone trail in the first place? Well, specifically for our problem, we want to avoid strengthening paths that initially look more interesting but do not ultimately lead to a close to optimal solution. Remember, during the pheromone matrix initialization, we already favored shorter paths by giving them a higher probability. Although some randomization is built into the path choice, we want to keep some sense of exploration in the system, and as such, we do not want to infinitely strengthen already strong paths while at the same time discouraging paths that seemed very unlikely to lead to ideal results. So we slightly lower the intensity of each pheromone trail over time. Practically, when a certain node path has a probability of 0.45, its new value will be (1 - 0.45) x 0.45 = 0.2475. A path with a probability of 0.1 will evaporate to (1 - 0.1) x 0 .1 = 0.09. Stronger paths will have stronger evaporation than weak paths.</p>

<p>Of course, paths that lead to great overall results (meaning shorter cycle lengths) are to be encouraged. This is why we also have a positive feedback loop in the form of releasing pheromones:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">pheromone_release</span><span class="p">(</span><span class="n">vertices</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">best_cycle</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
                      <span class="n">best_cycle_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">pheromones</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="s">"""Perform pheromone release, with elitism towards shorter cycles"""</span>
    <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">cycle</span><span class="p">:</span>
            <span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">weight</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">best_cycle</span><span class="p">:</span>
        <span class="n">pheromones</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">best_cycle_length</span>

    <span class="k">return</span> <span class="n">pheromones</span>
</code></pre></div></div>

<p>For each vertex in the cycle, we increase the pheromones on that vertex by 1 divided by the weight (in our case, the distance between the nodes on each side of the vertex). Simply put, shorter paths will be rewarded more than longer paths, and their pheromone trail will be enforced much more strongly. On top of this, just like we implemented a form of elitism in the case of our genetic algorithm, we will do so here. We‚Äôll also add some extra pheromone strength to each path in the best cycle we‚Äôve found so far.</p>

<p>The combination of this negative and positive feedback loop, applied to the results of the traversals of each ant in the swarm over multiple swarms in time, will very quickly lead to a close to optimal shortest path through the entire graph. The code is quite easy and was quickly implemented. Compared to the genetic algorithm, though, the explainability of the entire algorithm (although the steps in and of themselves are fairly clear) is lower than in the case of genetic algorithms. Intuitively, it‚Äôs much easier to reason about how and exactly why genetic algorithms lead to a high-quality approximation than for ant colony optimization. Maybe you feel differently, though. In any case, both are amazing algorithms that are quite easy to implement, and it doesn‚Äôt stop to amaze me how quickly both of them converge to a very high quality approximation of the ideal solution.</p>

<h3 id="concluding">Concluding</h3>

<p>Well, that‚Äôs about all I have to say about this topic for now. Since I always wanted to dabble in genetic algorithms and ant colony optimization, this was a nice little project to keep me occupied for a few days. It took me a few months to start this actual blog, but I‚Äôm currently investing pretty much all my spare time into learning Rust, so this is definitely the last Python project I‚Äôll post for a while. I already use Python in my day-to-day work, and since I do heavily prefer statically typed compiled languages and I‚Äôm a sucker for performance, expect a lot of Rust in the future. I‚Äôm currently playing around with cloth simulation, wave function collapse, and procedural generation, so expect several of those (and other) little adventures to appear here soon. I played around with a fractal zoomer for the Mandelbrot set using <a href="https://github.com/taichi-dev/taichi" target="_blank">Taichi</a> to get it to run on the GPU, but I‚Äôm thinking to<br />
<img src="http://localhost:4000/assets/tsp/rewriteinrust.jpg" alt="rewrite in rust" /><br />
and use <a href="https://bevyengine.org/" target="_blank">Bevy</a>, since that will probably enable me to zoom into fractals even further than what Python allows me to crunch out. We‚Äôll see. If not, I‚Äôll update this article with the GitHub link to my Python project. So much to do, so little time üòâ</p>

<p>In any case, thank you for reading this (if you got through it at all, I wouldn‚Äôt blame you otherwise). I do hope it sparked some interest and you learned something! I‚Äôm 100% only a rookie concerning genetic algorithms and ant colony optimization, but this project and the little bit of study I needed to crank it out at least familiarized me with the concepts involved. I hope this inspires at least some people to lay off the ChatGPT‚Äôs of the world and learn new stuff the old-school way, because it‚Äôs just a whole lot of fun üòâ Take it from me, though: don‚Äôt learn a few new algorithms, make an example implementation in 3 days, and then set it aside for 4 months so you have to relearn it all real quick for the blog post üòÄ not the most efficient use of time.</p>

  </section>
  <section id="disqus_thread"></section><!-- /#disqus_thread -->
</article>

    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'http://localhost:4000/2023/traveling-salesman/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2023/traveling-salesman'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
      };

      (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = '//peculiar-coding-endeavours.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
       })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>



      </div>

      <footer class="footer">
  <span class="footer__copyright">&copy; 2025 Tom van Schaijk. All rights reserved.</span>
</footer>

<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script type="text/javascript" src="/js/main.js?1737851978490887900"></script>


    </div>

<!-- load mathjax -->
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

  </body>
</html>